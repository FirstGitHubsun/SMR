ae_chunk_data	ae_chunking.cpp	/^int ae_chunk_data(unsigned char *p, int n) {$/;"	f
ae_init	ae_chunking.cpp	/^void ae_init(){$/;"	f
my_memcmp	ae_chunking.cpp	8;"	d	file:
window_size	ae_chunking.cpp	/^static int window_size = 0;$/;"	v	file:
area	assembly_restore.cpp	/^	GSequence *area;$/;"	m	struct:__anon1	file:
area_size	assembly_restore.cpp	/^	int64_t area_size;$/;"	m	struct:__anon1	file:
assemble_area	assembly_restore.cpp	/^static GQueue* assemble_area() {$/;"	f	file:
assembly_area	assembly_restore.cpp	/^} assembly_area;$/;"	v	typeref:struct:__anon1
assembly_area_push	assembly_restore.cpp	/^static int assembly_area_push(struct chunk* c) {$/;"	f	file:
assembly_restore_thread	assembly_restore.cpp	/^void* assembly_restore_thread(void *arg) {$/;"	f
init_assembly_area	assembly_restore.cpp	/^static void init_assembly_area() {$/;"	f	file:
size	assembly_restore.cpp	/^	int64_t size;$/;"	m	struct:__anon1	file:
BACKUP_H_	backup.h	9;"	d
DEKHash	bloom_filter.cpp	/^unsigned int DEKHash(unsigned char *str, unsigned int len)$/;"	f
DJBHash	bloom_filter.cpp	/^unsigned int DJBHash(unsigned char *str, unsigned int len)$/;"	f
FNVHash	bloom_filter.cpp	/^unsigned int FNVHash(unsigned char *str, unsigned int len)$/;"	f
JSHash	bloom_filter.cpp	/^unsigned int JSHash(unsigned char *str, unsigned int len)$/;"	f
PJWHash	bloom_filter.cpp	/^unsigned int PJWHash(unsigned char *str, unsigned int len)$/;"	f
RSHash	bloom_filter.cpp	/^unsigned int RSHash(unsigned char *str, unsigned int len)$/;"	f
SDBMHash	bloom_filter.cpp	/^unsigned int SDBMHash(unsigned char *str, unsigned int len)$/;"	f
hash_func	bloom_filter.cpp	/^unsigned int (*hash_func[])(unsigned char *, unsigned int) = { $/;"	v
in_dict	bloom_filter.cpp	/^int in_dict(unsigned char filter[], char *str, int len)$/;"	f
insert_word	bloom_filter.cpp	/^void insert_word(unsigned char filter[], char *str, int len)$/;"	f
BF_H_	bloom_filter.h	2;"	d
FILTER_BITMASK	bloom_filter.h	10;"	d
FILTER_SIZE	bloom_filter.h	7;"	d
FILTER_SIZE_BYTES	bloom_filter.h	9;"	d
NUM_HASHES	bloom_filter.h	8;"	d
cap_rewrite	cap_rewrite.cpp	/^void *cap_rewrite(void* arg) {$/;"	f
cap_segment_get_top	cap_rewrite.cpp	/^static void cap_segment_get_top() {$/;"	f	file:
chunk_num	cap_rewrite.cpp	/^static int64_t chunk_num;$/;"	v	file:
top	cap_rewrite.cpp	/^static GHashTable *top;$/;"	v	file:
buckets	cbr_rewrite.cpp	/^	int32_t buckets[10000];$/;"	m	struct:__anon2	file:
cbr_rewrite	cbr_rewrite.cpp	/^void *cbr_rewrite(void* arg) {$/;"	f
chunk_num	cbr_rewrite.cpp	/^	int32_t chunk_num;$/;"	m	struct:__anon2	file:
chunk_num	cbr_rewrite.cpp	/^static int64_t chunk_num;$/;"	v	file:
current_utility_threshold	cbr_rewrite.cpp	/^	double current_utility_threshold;$/;"	m	struct:__anon2	file:
get_rewrite_utility	cbr_rewrite.cpp	/^static double get_rewrite_utility(struct chunk *c) {$/;"	f	file:
init_utility_buckets	cbr_rewrite.cpp	/^void init_utility_buckets() {$/;"	f
min_index	cbr_rewrite.cpp	/^	int min_index;$/;"	m	struct:__anon2	file:
utility_buckets	cbr_rewrite.cpp	/^} utility_buckets;$/;"	v	typeref:struct:__anon2
utility_buckets_update	cbr_rewrite.cpp	/^static void utility_buckets_update(double rewrite_utility) {$/;"	f	file:
cfl_rewrite	cfl_rewrite.cpp	/^void *cfl_rewrite(void* arg) {$/;"	f
chunk_num	cfl_rewrite.cpp	/^static int64_t chunk_num;$/;"	v	file:
chunk_num	chunk_phase.cpp	/^static int64_t chunk_num;$/;"	v	file:
chunk_queue	chunk_phase.cpp	/^SyncQueue* chunk_queue;$/;"	v
chunk_t	chunk_phase.cpp	/^static pthread_t chunk_t;$/;"	v	file:
chunk_thread	chunk_phase.cpp	/^static void* chunk_thread(void *arg) {$/;"	f	file:
chunking	chunk_phase.cpp	/^static int (*chunking)(unsigned char* buf, int size);$/;"	v	file:
fixed_chunk_data	chunk_phase.cpp	/^static inline int fixed_chunk_data(unsigned char* buf, int size){$/;"	f	file:
start_chunk_phase	chunk_phase.cpp	/^void start_chunk_phase() {$/;"	f
stop_chunk_phase	chunk_phase.cpp	/^void stop_chunk_phase() {$/;"	f
CHUNK_H_	chunking.h	6;"	d
id	cma.cpp	/^    containerid id;$/;"	m	struct:record	file:
record	cma.cpp	/^struct record{$/;"	s	file:
time	cma.cpp	/^    int time;$/;"	m	struct:record	file:
trunc_manifest	cma.cpp	/^GHashTable* trunc_manifest(int jobid){$/;"	f
update_manifest	cma.cpp	/^void update_manifest(GHashTable *monitor){$/;"	f
CMA_H_	cma.h	2;"	d
load_config	config.cpp	/^void load_config() {$/;"	f
load_config_from_string	config.cpp	/^void load_config_from_string(sds config) {$/;"	f
yesnotoi	config.cpp	/^int yesnotoi(char *s) {$/;"	f
add_chunk_to_container	containerstore.cpp	/^int add_chunk_to_container(struct container* c, struct chunk* ck) {$/;"	f
append_t	containerstore.cpp	/^static pthread_t append_t;$/;"	v	file:
append_thread	containerstore.cpp	/^static void* append_thread(void *arg) {$/;"	f	file:
close_container_store	containerstore.cpp	/^void close_container_store() {$/;"	f
container_buffer	containerstore.cpp	/^static SyncQueue* container_buffer;$/;"	v	file:
container_check_id	containerstore.cpp	/^int container_check_id(void *c1, void *id1) {$/;"	f
container_count	containerstore.cpp	/^static int64_t container_count = 0;$/;"	v	file:
container_empty	containerstore.cpp	/^int container_empty(struct container* c) {$/;"	f
container_meta_check_id	containerstore.cpp	/^int container_meta_check_id(void *cm1, void *id1) {$/;"	f
container_meta_duplicate	containerstore.cpp	/^static void * container_meta_duplicate(void *c1) {$/;"	f	file:
container_meta_foreach	containerstore.cpp	/^void container_meta_foreach(struct containerMeta* cm, void (*func)(fingerprint*, void*), void* data){$/;"	f
container_overflow	containerstore.cpp	/^int container_overflow(struct container* c, int32_t size) {$/;"	f
create_container	containerstore.cpp	/^struct container* create_container() {$/;"	f
fp	containerstore.cpp	/^	fingerprint fp;$/;"	m	struct:metaEntry	file:
fp	containerstore.cpp	/^static FILE* fp;$/;"	v	file:
free_container	containerstore.cpp	/^void free_container(void * c1) {$/;"	f
free_container_meta	containerstore.cpp	/^void free_container_meta(void * cm1){$/;"	f
g_container_cmp_desc	containerstore.cpp	/^gint g_container_cmp_desc(struct container* c1, struct container* c2,$/;"	f
g_container_meta_cmp_desc	containerstore.cpp	/^gint g_container_meta_cmp_desc(struct containerMeta* cm1,$/;"	f
get_chunk_in_container	containerstore.cpp	/^struct chunk* get_chunk_in_container(struct container* c, fingerprint *fp) {$/;"	f
get_container_id	containerstore.cpp	/^inline containerid get_container_id(struct container* c) {$/;"	f
get_metaentry_in_container_meta	containerstore.cpp	/^static struct metaEntry* get_metaentry_in_container_meta($/;"	f	file:
init_container_meta	containerstore.cpp	/^static void init_container_meta(struct containerMeta *meta) {$/;"	f	file:
init_container_store	containerstore.cpp	/^void init_container_store() {$/;"	f
len	containerstore.cpp	/^	int32_t len;$/;"	m	struct:metaEntry	file:
lookup_fingerprint_in_container	containerstore.cpp	/^int lookup_fingerprint_in_container(void *c1, void *fp1) {$/;"	f
lookup_fingerprint_in_container_meta	containerstore.cpp	/^int lookup_fingerprint_in_container_meta(void *cm1, void *fp1) {$/;"	f
metaEntry	containerstore.cpp	/^struct metaEntry {$/;"	s	file:
mutex	containerstore.cpp	/^static pthread_mutex_t mutex;$/;"	v	file:
off	containerstore.cpp	/^	int32_t off;$/;"	m	struct:metaEntry	file:
retrieve_container_by_id	containerstore.cpp	/^struct container* retrieve_container_by_id(containerid id) {$/;"	f
retrieve_container_meta_by_id	containerstore.cpp	/^struct containerMeta* retrieve_container_meta_by_id(containerid id) {$/;"	f
write_container	containerstore.cpp	/^void write_container(struct container* c) {$/;"	f
write_container_async	containerstore.cpp	/^void write_container_async(struct container* c) {$/;"	f
CONTAINERSTORE_H_	containerstore.h	9;"	d
CONTAINER_HEAD	containerstore.h	15;"	d
CONTAINER_META_ENTRY	containerstore.h	16;"	d
CONTAINER_META_SIZE	containerstore.h	14;"	d
CONTAINER_SIZE	containerstore.h	13;"	d
chunk_num	containerstore.h	/^	int32_t chunk_num;$/;"	m	struct:containerMeta
container	containerstore.h	/^struct container {$/;"	s
containerMeta	containerstore.h	/^struct containerMeta {$/;"	s
data	containerstore.h	/^	unsigned char *data;$/;"	m	struct:container
data_size	containerstore.h	/^	int32_t data_size;$/;"	m	struct:containerMeta
id	containerstore.h	/^	containerid id;$/;"	m	struct:containerMeta
map	containerstore.h	/^	GHashTable *map;$/;"	m	struct:containerMeta
meta	containerstore.h	/^	struct containerMeta meta;$/;"	m	struct:container	typeref:struct:container::containerMeta
chunk_num	dedup_phase.cpp	/^static int64_t chunk_num;$/;"	v	file:
cond	dedup_phase.cpp	/^	pthread_cond_t cond; \/\/ index buffer is not full$/;"	m	struct:__anon3	file:
dedup_queue	dedup_phase.cpp	/^SyncQueue* dedup_queue;$/;"	v
dedup_t	dedup_phase.cpp	/^static pthread_t dedup_t;$/;"	v	file:
dedup_thread	dedup_phase.cpp	/^void *dedup_thread(void *arg) {$/;"	f
index_lock	dedup_phase.cpp	/^} index_lock;$/;"	v	typeref:struct:__anon3
mutex	dedup_phase.cpp	/^	pthread_mutex_t mutex;$/;"	m	struct:__anon3	file:
segment_num	dedup_phase.cpp	/^static int64_t segment_num;$/;"	v	file:
send_segment	dedup_phase.cpp	/^void send_segment(struct segment* s) {$/;"	f
start_dedup_phase	dedup_phase.cpp	/^void start_dedup_phase() {$/;"	f
stop_dedup_phase	dedup_phase.cpp	/^void stop_dedup_phase() {$/;"	f
wait_threshold	dedup_phase.cpp	/^	int wait_threshold;$/;"	m	struct:__anon3	file:
check_simulation_level	destor.cpp	/^void check_simulation_level(int last_level, int current_level) {$/;"	f
destor	destor.cpp	/^struct structdestor destor;$/;"	v	typeref:struct:structdestor
destor_log	destor.cpp	/^void destor_log(int level, const char *fmt, ...) {$/;"	f
destor_shutdown	destor.cpp	/^void destor_shutdown() {$/;"	f
destor_start	destor.cpp	/^void destor_start() {$/;"	f
destor_stat	destor.cpp	/^void destor_stat() {$/;"	f
free_chunk	destor.cpp	/^void free_chunk(struct chunk* ck) {$/;"	f
free_segment	destor.cpp	/^void free_segment(struct segment* s) {$/;"	f
g_chunk_cmp	destor.cpp	/^gint g_chunk_cmp(struct chunk* a, struct chunk* b, gpointer user_data){$/;"	f
g_fingerprint_cmp	destor.cpp	/^gint g_fingerprint_cmp(fingerprint* fp1, fingerprint* fp2, gpointer user_data) {$/;"	f
g_fingerprint_equal	destor.cpp	/^gboolean g_fingerprint_equal(fingerprint* fp1, fingerprint* fp2) {$/;"	f
long_options	destor.cpp	/^struct option long_options[] = {$/;"	v	typeref:struct:option
main	destor.cpp	/^int main(int argc, char **argv) {$/;"	f
new_chunk	destor.cpp	/^struct chunk* new_chunk(int32_t size) {$/;"	f
new_segment	destor.cpp	/^struct segment* new_segment() {$/;"	f
new_segment_full	destor.cpp	/^struct segment* new_segment_full(){$/;"	f
short_options	destor.cpp	/^const char * const short_options = "sr::t::p::h";$/;"	v
usage	destor.cpp	/^void usage() {$/;"	f
CHECK_CHUNK	destor.h	192;"	d
CHUNK_AE	destor.h	70;"	d
CHUNK_DUPLICATE	destor.h	172;"	d
CHUNK_FILE	destor.h	69;"	d
CHUNK_FILE_END	destor.h	182;"	d
CHUNK_FILE_START	destor.h	181;"	d
CHUNK_FIXED	destor.h	66;"	d
CHUNK_IN_CACHE	destor.h	176;"	d
CHUNK_NORMALIZED_RABIN	destor.h	68;"	d
CHUNK_OUT_OF_ORDER	destor.h	174;"	d
CHUNK_RABIN	destor.h	67;"	d
CHUNK_READY	destor.h	188;"	d
CHUNK_REWRITE_DENIED	destor.h	178;"	d
CHUNK_SEGMENT_END	destor.h	184;"	d
CHUNK_SEGMENT_START	destor.h	183;"	d
CHUNK_SPARSE	destor.h	173;"	d
CHUNK_TTTD	destor.h	71;"	d
CHUNK_UNIQUE	destor.h	171;"	d
CHUNK_WAIT	destor.h	187;"	d
DEBUG	destor.h	318;"	d
DEFAULT_BLOCK_SIZE	destor.h	168;"	d
DESTOR_BACKUP	destor.h	43;"	d
DESTOR_CONFIGLINE_MAX	destor.h	41;"	d
DESTOR_DEBUG	destor.h	49;"	d
DESTOR_DEFAULT_VERBOSITY	destor.h	53;"	d
DESTOR_DELETE	destor.h	46;"	d
DESTOR_H_	destor.h	9;"	d
DESTOR_MAKE_TRACE	destor.h	45;"	d
DESTOR_MAX_LOGMSG_LEN	destor.h	54;"	d
DESTOR_NOTICE	destor.h	51;"	d
DESTOR_RESTORE	destor.h	44;"	d
DESTOR_VERBOSE	destor.h	50;"	d
DESTOR_WARNING	destor.h	52;"	d
INDEX_CATEGORY_EXACT	destor.h	80;"	d
INDEX_CATEGORY_LOGICAL	destor.h	95;"	d
INDEX_CATEGORY_LOGICAL_LOCALITY	destor.h	102;"	d
INDEX_CATEGORY_NEAR_EXACT	destor.h	87;"	d
INDEX_CATEGORY_PHYSICAL_LOCALITY	destor.h	94;"	d
INDEX_CATEGORY_SIMILARITY	destor.h	103;"	d
INDEX_KEY_VALUE_HTABLE	destor.h	109;"	d
INDEX_KEY_VALUE_MYSQL	destor.h	110;"	d
INDEX_SAMPLING_MIN	destor.h	122;"	d
INDEX_SAMPLING_OPTIMIZED_MIN	destor.h	124;"	d
INDEX_SAMPLING_RANDOM	destor.h	121;"	d
INDEX_SAMPLING_UNIFORM	destor.h	123;"	d
INDEX_SEGMENT_CONTENT_DEFINED	destor.h	132;"	d
INDEX_SEGMENT_FILE_DEFINED	destor.h	133;"	d
INDEX_SEGMENT_FIXED	destor.h	131;"	d
INDEX_SEGMENT_SELECT_BASE	destor.h	140;"	d
INDEX_SEGMENT_SELECT_MIX	destor.h	142;"	d
INDEX_SEGMENT_SELECT_TOP	destor.h	141;"	d
INDEX_SPECIFIC_BLOCK_LOCALITY_CACHING	destor.h	154;"	d
INDEX_SPECIFIC_DDFS	destor.h	149;"	d
INDEX_SPECIFIC_EXTREME_BINNING	destor.h	150;"	d
INDEX_SPECIFIC_NO	destor.h	148;"	d
INDEX_SPECIFIC_SAMPLED	destor.h	153;"	d
INDEX_SPECIFIC_SILO	destor.h	151;"	d
INDEX_SPECIFIC_SPARSE	destor.h	152;"	d
NOTICE	destor.h	320;"	d
RESTORE_CACHE_ASM	destor.h	158;"	d
RESTORE_CACHE_LRU	destor.h	156;"	d
RESTORE_CACHE_OPT	destor.h	157;"	d
REWRITE_CAPPING	destor.h	163;"	d
REWRITE_CFL_SELECTIVE_DEDUPLICATION	destor.h	161;"	d
REWRITE_CONTEXT_BASED	destor.h	162;"	d
REWRITE_NO	destor.h	160;"	d
SET_CHUNK	destor.h	190;"	d
SIMULATION_ALL	destor.h	60;"	d
SIMULATION_APPEND	destor.h	59;"	d
SIMULATION_NO	destor.h	57;"	d
SIMULATION_RESTORE	destor.h	58;"	d
TEMPORARY_ID	destor.h	165;"	d
TIMER_BEGIN	destor.h	37;"	d
TIMER_DECLARE	destor.h	36;"	d
TIMER_END	destor.h	38;"	d
TRACE_DESTOR	destor.h	63;"	d
TRACE_FSL	destor.h	64;"	d
UNSET_CHUNK	destor.h	191;"	d
VERBOSE	destor.h	319;"	d
WARNING	destor.h	321;"	d
backup_retention_time	destor.h	/^	int backup_retention_time;$/;"	m	struct:structdestor
chunk	destor.h	/^struct chunk {$/;"	s
chunk_algorithm	destor.h	/^	int chunk_algorithm;$/;"	m	struct:structdestor
chunk_avg_size	destor.h	/^	int chunk_avg_size;$/;"	m	struct:structdestor
chunk_max_size	destor.h	/^	int chunk_max_size;$/;"	m	struct:structdestor
chunk_min_size	destor.h	/^	int chunk_min_size;$/;"	m	struct:structdestor
chunk_num	destor.h	/^	int32_t chunk_num;$/;"	m	struct:segment
chunk_num	destor.h	/^	int64_t chunk_num;$/;"	m	struct:structdestor
chunks	destor.h	/^	GSequence *chunks;$/;"	m	struct:segment
containerid	destor.h	/^typedef int64_t containerid; \/\/container id$/;"	t
data	destor.h	/^	unsigned char *data;$/;"	m	struct:chunk
data_size	destor.h	/^	int64_t data_size;$/;"	m	struct:structdestor
features	destor.h	/^	GHashTable* features;$/;"	m	struct:segment
fingerprint	destor.h	/^typedef unsigned char fingerprint[20];$/;"	t
flag	destor.h	/^	int flag;$/;"	m	struct:chunk
fp	destor.h	/^	fingerprint fp;$/;"	m	struct:chunk
id	destor.h	/^	containerid id;$/;"	m	struct:chunk
id	destor.h	/^	segmentid id;$/;"	m	struct:segment
index_bloom_filter_size	destor.h	/^	int index_bloom_filter_size;$/;"	m	struct:structdestor
index_cache_size	destor.h	/^	int index_cache_size;$/;"	m	struct:structdestor
index_category	destor.h	/^	int index_category[2];$/;"	m	struct:structdestor
index_key_size	destor.h	/^	int index_key_size;$/;"	m	struct:structdestor
index_key_value_store	destor.h	/^	int index_key_value_store;$/;"	m	struct:structdestor
index_memory_footprint	destor.h	/^	int32_t index_memory_footprint;$/;"	m	struct:structdestor
index_sampling_method	destor.h	/^	int index_sampling_method[2];$/;"	m	struct:structdestor
index_segment_algorithm	destor.h	/^	int index_segment_algorithm[2];$/;"	m	struct:structdestor
index_segment_max	destor.h	/^	int index_segment_max;$/;"	m	struct:structdestor
index_segment_min	destor.h	/^	int index_segment_min;$/;"	m	struct:structdestor
index_segment_prefech	destor.h	/^	int index_segment_prefech;$/;"	m	struct:structdestor
index_segment_selection_method	destor.h	/^	int index_segment_selection_method[2];$/;"	m	struct:structdestor
index_specific	destor.h	/^	int index_specific;$/;"	m	struct:structdestor
index_value_length	destor.h	/^	int index_value_length;$/;"	m	struct:structdestor
live_container_num	destor.h	/^	int32_t live_container_num;$/;"	m	struct:structdestor
restore_cache	destor.h	/^	int restore_cache[2];$/;"	m	struct:structdestor
restore_opt_window_size	destor.h	/^	int restore_opt_window_size;$/;"	m	struct:structdestor
rewrite_algorithm	destor.h	/^	int rewrite_algorithm[2];$/;"	m	struct:structdestor
rewrite_capping_level	destor.h	/^	int rewrite_capping_level;$/;"	m	struct:structdestor
rewrite_cbr_limit	destor.h	/^	double rewrite_cbr_limit;$/;"	m	struct:structdestor
rewrite_cbr_minimal_utility	destor.h	/^	double rewrite_cbr_minimal_utility;$/;"	m	struct:structdestor
rewrite_cfl_require	destor.h	/^	double rewrite_cfl_require;$/;"	m	struct:structdestor
rewrite_cfl_usage_threshold	destor.h	/^	double rewrite_cfl_usage_threshold;$/;"	m	struct:structdestor
rewrite_enable_cache_aware	destor.h	/^	int rewrite_enable_cache_aware;$/;"	m	struct:structdestor
rewrite_enable_cfl_switch	destor.h	/^	int rewrite_enable_cfl_switch;$/;"	m	struct:structdestor
rewrite_enable_har	destor.h	/^	int rewrite_enable_har;$/;"	m	struct:structdestor
rewrite_har_rewrite_limit	destor.h	/^	double rewrite_har_rewrite_limit;$/;"	m	struct:structdestor
rewrite_har_utilization_threshold	destor.h	/^	double rewrite_har_utilization_threshold;$/;"	m	struct:structdestor
rewritten_chunk_num	destor.h	/^	int64_t rewritten_chunk_num;$/;"	m	struct:structdestor
rewritten_chunk_size	destor.h	/^	int64_t rewritten_chunk_size;$/;"	m	struct:structdestor
segment	destor.h	/^struct segment {$/;"	s
segmentid	destor.h	/^typedef int64_t segmentid;$/;"	t
simulation_level	destor.h	/^	int simulation_level;$/;"	m	struct:structdestor
size	destor.h	/^	int32_t size;$/;"	m	struct:chunk
stored_chunk_num	destor.h	/^	int64_t stored_chunk_num;$/;"	m	struct:structdestor
stored_data_size	destor.h	/^	int64_t stored_data_size;$/;"	m	struct:structdestor
structdestor	destor.h	/^struct structdestor {$/;"	s
trace_format	destor.h	/^    int trace_format;$/;"	m	struct:structdestor
verbosity	destor.h	/^	int verbosity;$/;"	m	struct:structdestor
working_directory	destor.h	/^	sds working_directory;$/;"	m	struct:structdestor
zero_chunk_num	destor.h	/^	int64_t zero_chunk_num;$/;"	m	struct:structdestor
zero_chunk_size	destor.h	/^	int64_t zero_chunk_size;$/;"	m	struct:structdestor
do_backup	do_backup.cpp	/^void do_backup(char *path) {$/;"	f
lookup_requests	do_backup.cpp	/^	int lookup_requests;$/;"	m	struct:__anon4	file:
lookup_requests_for_unique	do_backup.cpp	/^	int lookup_requests_for_unique;$/;"	m	struct:__anon4	file:
read_prefetching_units	do_backup.cpp	/^	int read_prefetching_units;$/;"	m	struct:__anon4	file:
update_requests	do_backup.cpp	/^	int update_requests;$/;"	m	struct:__anon4	file:
delete_an_entry	do_delete.cpp	/^static inline void delete_an_entry(fingerprint *fp, void *id1){$/;"	f	file:
do_delete	do_delete.cpp	/^void do_delete(int jobid) {$/;"	f
do_restore	do_restore.cpp	/^void do_restore(int revision, char *path) {$/;"	f
lru_restore_thread	do_restore.cpp	/^static void* lru_restore_thread(void *arg) {$/;"	f	file:
read_recipe_thread	do_restore.cpp	/^static void* read_recipe_thread(void *arg) {$/;"	f	file:
restore_chunk_queue	do_restore.cpp	/^SyncQueue *restore_chunk_queue;$/;"	v
restore_recipe_queue	do_restore.cpp	/^SyncQueue *restore_recipe_queue;$/;"	v
write_restore_data	do_restore.cpp	/^void* write_restore_data(void* arg) {$/;"	f
chunk_num	filter_phase.cpp	/^static int64_t chunk_num;$/;"	v	file:
chunks	filter_phase.cpp	/^	GSequence *chunks;$/;"	m	struct:__anon5	file:
cond	filter_phase.cpp	/^	GCond cond; \/\/ index buffer is not full$/;"	m	struct:__anon6	file:
container_buffer	filter_phase.cpp	/^	struct container *container_buffer;$/;"	m	struct:__anon5	typeref:struct:__anon5::container	file:
filter_t	filter_phase.cpp	/^static pthread_t filter_t;$/;"	v	file:
filter_thread	filter_phase.cpp	/^static void* filter_thread(void *arg) {$/;"	f	file:
mutex	filter_phase.cpp	/^	GMutex mutex;$/;"	m	struct:__anon6	file:
start_filter_phase	filter_phase.cpp	/^void start_filter_phase() {$/;"	f
stop_filter_phase	filter_phase.cpp	/^void stop_filter_phase() {$/;"	f
storage_buffer	filter_phase.cpp	/^} storage_buffer;$/;"	v	typeref:struct:__anon5
wait_threshold	filter_phase.cpp	/^	int wait_threshold;$/;"	m	struct:__anon6	file:
fingerprint_cache_lookup	fingerprint_cache.cpp	/^int64_t fingerprint_cache_lookup(fingerprint *fp){$/;"	f
fingerprint_cache_prefetch	fingerprint_cache.cpp	/^void fingerprint_cache_prefetch(int64_t id){$/;"	f
init_fingerprint_cache	fingerprint_cache.cpp	/^void init_fingerprint_cache(){$/;"	f
lookup_requests	fingerprint_cache.cpp	/^	int lookup_requests;$/;"	m	struct:__anon7	file:
lookup_requests_for_unique	fingerprint_cache.cpp	/^	int lookup_requests_for_unique;$/;"	m	struct:__anon7	file:
lru_queue	fingerprint_cache.cpp	/^static struct lruCache* lru_queue;$/;"	v	typeref:struct:lruCache	file:
read_prefetching_units	fingerprint_cache.cpp	/^	int read_prefetching_units;$/;"	m	struct:__anon7	file:
update_requests	fingerprint_cache.cpp	/^	int update_requests;$/;"	m	struct:__anon7	file:
FINGERPRINT_CACHE_H_	fingerprint_cache.h	9;"	d
close_har	har_rewrite.cpp	/^void close_har() {$/;"	f
container_utilization_monitor	har_rewrite.cpp	/^static GHashTable *container_utilization_monitor;$/;"	v	file:
g_record_cmp	har_rewrite.cpp	/^static gint g_record_cmp(struct containerRecord *a, struct containerRecord* b, gpointer user_data){$/;"	f	file:
har_check	har_rewrite.cpp	/^void har_check(struct chunk* c) {$/;"	f
har_monitor_update	har_rewrite.cpp	/^void har_monitor_update(containerid id, int32_t size) {$/;"	f
inherited_sparse_containers	har_rewrite.cpp	/^static GHashTable *inherited_sparse_containers;$/;"	v	file:
init_har	har_rewrite.cpp	/^void init_har() {$/;"	f
chunk_num	hash_phase.cpp	/^static int64_t chunk_num;$/;"	v	file:
hash_queue	hash_phase.cpp	/^SyncQueue* hash_queue;$/;"	v
hash_t	hash_phase.cpp	/^static pthread_t hash_t;$/;"	v	file:
sha1_thread	hash_phase.cpp	/^static void* sha1_thread(void* arg) {$/;"	f	file:
start_hash_phase	hash_phase.cpp	/^void start_hash_phase() {$/;"	f
stop_hash_phase	hash_phase.cpp	/^void stop_hash_phase() {$/;"	f
chunks	index.cpp	/^    GSequence *chunks;$/;"	m	struct:__anon8	file:
close_index	index.cpp	/^void close_index() {$/;"	f
cond	index.cpp	/^    GCond cond; \/\/ index buffer is not full$/;"	m	struct:__anon9	file:
container_buffer	index.cpp	/^    struct container *container_buffer;$/;"	m	struct:__anon8	typeref:struct:__anon8::container	file:
g_feature_equal	index.cpp	/^gboolean g_feature_equal(char* a, char* b){$/;"	f
g_feature_hash	index.cpp	/^guint g_feature_hash(char *feature){$/;"	f
index_buffer	index.cpp	/^struct index_buffer index_buffer;$/;"	v	typeref:struct:index_buffer
index_check_buffer	index.cpp	/^void index_check_buffer(struct segment *s) {$/;"	f
index_delete	index.cpp	/^inline void index_delete(fingerprint *fp, int64_t id){$/;"	f
index_lookup	index.cpp	/^int index_lookup(struct segment* s) {$/;"	f
index_lookup_base	index.cpp	/^static void index_lookup_base(struct segment *s){$/;"	f	file:
index_overhead	index.cpp	/^struct index_overhead index_overhead;$/;"	v	typeref:struct:index_overhead
index_update	index.cpp	/^void index_update(GHashTable *features, int64_t id){$/;"	f
index_update_buffer	index.cpp	/^int index_update_buffer(struct segment *s){$/;"	f
init_index	index.cpp	/^void init_index() {$/;"	f
mutex	index.cpp	/^    GMutex mutex;$/;"	m	struct:__anon9	file:
wait_threshold	index.cpp	/^    int wait_threshold;$/;"	m	struct:__anon9	file:
INDEX_H_	index.h	10;"	d
INDEX_BUFFER_H_	index_buffer.h	2;"	d
buffered_fingerprints	index_buffer.h	/^    GHashTable *buffered_fingerprints;$/;"	m	struct:index_buffer
chunk_num	index_buffer.h	/^    int chunk_num;$/;"	m	struct:index_buffer
fp	index_buffer.h	/^    fingerprint fp;$/;"	m	struct:indexElem
id	index_buffer.h	/^    containerid id;$/;"	m	struct:indexElem
indexElem	index_buffer.h	/^struct indexElem {$/;"	s
index_buffer	index_buffer.h	/^struct index_buffer {$/;"	s
index_overhead	index_buffer.h	/^struct index_overhead {$/;"	s
lookup_requests	index_buffer.h	/^    int lookup_requests;$/;"	m	struct:index_overhead
lookup_requests_for_unique	index_buffer.h	/^    int lookup_requests_for_unique;$/;"	m	struct:index_overhead
read_prefetching_units	index_buffer.h	/^    int read_prefetching_units;$/;"	m	struct:index_overhead
update_requests	index_buffer.h	/^    int update_requests;$/;"	m	struct:index_overhead
init_backup_jcr	jcr.cpp	/^void init_backup_jcr(char *path) {$/;"	f
init_jcr	jcr.cpp	/^void init_jcr(char *path) {$/;"	f
init_restore_jcr	jcr.cpp	/^void init_restore_jcr(int revision, char *path) {$/;"	f
jcr	jcr.cpp	/^struct jcr jcr;$/;"	v	typeref:struct:jcr
JCR_STATUS_DONE	jcr.h	17;"	d
JCR_STATUS_INIT	jcr.h	15;"	d
JCR_STATUS_RUNNING	jcr.h	16;"	d
Jcr_H_	jcr.h	9;"	d
bv	jcr.h	/^	struct backupVersion* bv;$/;"	m	struct:jcr	typeref:struct:jcr::backupVersion
chunk_num	jcr.h	/^	int32_t chunk_num;$/;"	m	struct:jcr
chunk_time	jcr.h	/^	double chunk_time;$/;"	m	struct:jcr
data_size	jcr.h	/^	int64_t data_size;$/;"	m	struct:jcr
dedup_time	jcr.h	/^	double dedup_time;$/;"	m	struct:jcr
file_num	jcr.h	/^	int32_t file_num;$/;"	m	struct:jcr
filter_time	jcr.h	/^	double filter_time;$/;"	m	struct:jcr
hash_time	jcr.h	/^	double hash_time;$/;"	m	struct:jcr
id	jcr.h	/^	int32_t id;$/;"	m	struct:jcr
inherited_sparse_num	jcr.h	/^	int32_t inherited_sparse_num;$/;"	m	struct:jcr
jcr	jcr.h	/^struct jcr{$/;"	s
path	jcr.h	/^	sds path;$/;"	m	struct:jcr
read_chunk_time	jcr.h	/^	double read_chunk_time;$/;"	m	struct:jcr
read_container_num	jcr.h	/^	int32_t read_container_num;$/;"	m	struct:jcr
read_recipe_time	jcr.h	/^	double read_recipe_time;$/;"	m	struct:jcr
read_time	jcr.h	/^	double read_time;$/;"	m	struct:jcr
rewrite_time	jcr.h	/^	double rewrite_time;$/;"	m	struct:jcr
rewritten_chunk_num	jcr.h	/^	int32_t rewritten_chunk_num;$/;"	m	struct:jcr
rewritten_chunk_size	jcr.h	/^	int64_t rewritten_chunk_size;$/;"	m	struct:jcr
sparse_container_num	jcr.h	/^	int32_t sparse_container_num;$/;"	m	struct:jcr
status	jcr.h	/^    int status;$/;"	m	struct:jcr
total_container_num	jcr.h	/^	int32_t total_container_num;$/;"	m	struct:jcr
total_time	jcr.h	/^	double total_time;$/;"	m	struct:jcr
unique_chunk_num	jcr.h	/^	int32_t unique_chunk_num;$/;"	m	struct:jcr
unique_data_size	jcr.h	/^	int64_t unique_data_size;$/;"	m	struct:jcr
write_chunk_time	jcr.h	/^	double write_chunk_time;$/;"	m	struct:jcr
write_time	jcr.h	/^	double write_time;$/;"	m	struct:jcr
zero_chunk_num	jcr.h	/^	int32_t zero_chunk_num;$/;"	m	struct:jcr
zero_chunk_size	jcr.h	/^	int64_t zero_chunk_size;$/;"	m	struct:jcr
close_kvstore	kvstore.cpp	/^void (*close_kvstore)();$/;"	v
init_kvstore	kvstore.cpp	/^void init_kvstore() {$/;"	f
kvstore_delete	kvstore.cpp	/^void (*kvstore_delete)(char* key, int64_t id);$/;"	v
kvstore_lookup	kvstore.cpp	/^int64_t* (*kvstore_lookup)(char *key);$/;"	v
kvstore_update	kvstore.cpp	/^void (*kvstore_update)(char *key, int64_t id);$/;"	v
KVSTORE_H_	kvstore.h	2;"	d
close_kvstore_htable	kvstore_htable.cpp	/^void close_kvstore_htable() {$/;"	f
free_kvpair	kvstore_htable.cpp	/^static inline void free_kvpair(kvpair kvp){$/;"	f	file:
get_key	kvstore_htable.cpp	13;"	d	file:
get_value	kvstore_htable.cpp	14;"	d	file:
htable	kvstore_htable.cpp	/^static GHashTable *htable;$/;"	v	file:
init_kvstore_htable	kvstore_htable.cpp	/^void init_kvstore_htable(){$/;"	f
kv_update	kvstore_htable.cpp	/^static void kv_update(kvpair kv, int64_t id){$/;"	f	file:
kvpair	kvstore_htable.cpp	/^typedef char* kvpair;$/;"	t	file:
kvpair_size	kvstore_htable.cpp	/^static int32_t kvpair_size;$/;"	v	file:
kvstore_htable_delete	kvstore_htable.cpp	/^void kvstore_htable_delete(char* key, int64_t id){$/;"	f
kvstore_htable_lookup	kvstore_htable.cpp	/^int64_t* kvstore_htable_lookup(char* key) {$/;"	f
kvstore_htable_update	kvstore_htable.cpp	/^void kvstore_htable_update(char* key, int64_t id) {$/;"	f
new_kvpair	kvstore_htable.cpp	/^static kvpair new_kvpair(){$/;"	f	file:
new_kvpair_full	kvstore_htable.cpp	/^static kvpair new_kvpair_full(char* key){$/;"	f	file:
FILE_HEADER_SIZE	libhashfile.cpp	37;"	d	file:
_FILE_OFFSET_BITS	libhashfile.cpp	16;"	d	file:
convert_to_abstract_file_header	libhashfile.cpp	/^static void convert_to_abstract_file_header(int version, uint8_t *fhdr,$/;"	f	file:
do_add_file	libhashfile.cpp	/^static int do_add_file(struct hashfile_handle *handle, const char *file_path,$/;"	f	file:
hashfile_add_chunk	libhashfile.cpp	/^int hashfile_add_chunk(struct hashfile_handle *handle,$/;"	f
hashfile_add_file	libhashfile.cpp	/^int hashfile_add_file(struct hashfile_handle *handle,$/;"	f
hashfile_chunking_method	libhashfile.cpp	/^enum chnking_method hashfile_chunking_method(struct hashfile_handle *handle)$/;"	f
hashfile_chunking_method_str	libhashfile.cpp	/^int hashfile_chunking_method_str(struct hashfile_handle *handle,$/;"	f
hashfile_close	libhashfile.cpp	/^void hashfile_close(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_atime	libhashfile.cpp	/^uint64_t hashfile_curfile_atime(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_blocks	libhashfile.cpp	/^uint64_t hashfile_curfile_blocks(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_ctime	libhashfile.cpp	/^uint64_t hashfile_curfile_ctime(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_deviceid	libhashfile.cpp	/^uint64_t hashfile_curfile_deviceid(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_gid	libhashfile.cpp	/^uint32_t hashfile_curfile_gid(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_hardlinks	libhashfile.cpp	/^uint64_t hashfile_curfile_hardlinks(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_inodenum	libhashfile.cpp	/^uint64_t hashfile_curfile_inodenum(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_linkpath	libhashfile.cpp	/^char *hashfile_curfile_linkpath(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_mtime	libhashfile.cpp	/^uint64_t hashfile_curfile_mtime(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_numchunks	libhashfile.cpp	/^uint64_t hashfile_curfile_numchunks(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_path	libhashfile.cpp	/^const char *hashfile_curfile_path(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_perm	libhashfile.cpp	/^uint64_t hashfile_curfile_perm(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_size	libhashfile.cpp	/^uint64_t hashfile_curfile_size(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_uid	libhashfile.cpp	/^uint32_t hashfile_curfile_uid(struct hashfile_handle *handle)$/;"	f
hashfile_end_time	libhashfile.cpp	/^uint64_t hashfile_end_time(struct hashfile_handle *handle)$/;"	f
hashfile_fxd_chunking_params	libhashfile.cpp	/^int hashfile_fxd_chunking_params(struct hashfile_handle *handle,$/;"	f
hashfile_hash_size	libhashfile.cpp	/^uint32_t hashfile_hash_size(struct hashfile_handle *handle)$/;"	f
hashfile_hashing_method	libhashfile.cpp	/^enum hshing_method hashfile_hashing_method(struct hashfile_handle *handle)$/;"	f
hashfile_hashing_method_str	libhashfile.cpp	/^int hashfile_hashing_method_str(struct hashfile_handle *handle,$/;"	f
hashfile_next_chunk	libhashfile.cpp	/^const struct chunk_info *hashfile_next_chunk(struct hashfile_handle *handle)$/;"	f
hashfile_next_file	libhashfile.cpp	/^int hashfile_next_file(struct hashfile_handle *handle)$/;"	f
hashfile_numbytes	libhashfile.cpp	/^uint64_t hashfile_numbytes(struct hashfile_handle *handle)$/;"	f
hashfile_numchunks	libhashfile.cpp	/^uint64_t hashfile_numchunks(struct hashfile_handle *handle)$/;"	f
hashfile_numfiles	libhashfile.cpp	/^uint64_t hashfile_numfiles(struct hashfile_handle *handle)$/;"	f
hashfile_open	libhashfile.cpp	/^struct hashfile_handle *hashfile_open(char *hashfile_name)$/;"	f
hashfile_open4write	libhashfile.cpp	/^struct hashfile_handle *hashfile_open4write(char *hashfile_name, enum$/;"	f
hashfile_reset	libhashfile.cpp	/^int hashfile_reset(struct hashfile_handle *handle)$/;"	f
hashfile_rootpath	libhashfile.cpp	/^const char *hashfile_rootpath(struct hashfile_handle *handle)$/;"	f
hashfile_set_fxd_chnking_params	libhashfile.cpp	/^int hashfile_set_fxd_chnking_params(struct hashfile_handle *handle,$/;"	f
hashfile_set_var_chnking_params	libhashfile.cpp	/^int hashfile_set_var_chnking_params(struct hashfile_handle *handle,$/;"	f
hashfile_start_time	libhashfile.cpp	/^uint64_t hashfile_start_time(struct hashfile_handle *handle)$/;"	f
hashfile_sysid	libhashfile.cpp	/^const char *hashfile_sysid(struct hashfile_handle *handle)$/;"	f
hashfile_var_chunking_params	libhashfile.cpp	/^int hashfile_var_chunking_params(struct hashfile_handle *handle,$/;"	f
hashfile_version	libhashfile.cpp	/^uint32_t hashfile_version(struct hashfile_handle *handle)$/;"	f
max	libhashfile.cpp	36;"	d	file:
max2	libhashfile.cpp	35;"	d	file:
skip_over_current_file_hashes	libhashfile.cpp	/^static uint64_t skip_over_current_file_hashes(struct hashfile_handle *handle)$/;"	f	file:
version_supported	libhashfile.cpp	/^static inline int version_supported(uint32_t version)$/;"	f	file:
CHUNK_SIZE_32BIT	libhashfile.h	371;"	d
CHUNK_SIZE_64BIT	libhashfile.h	372;"	d
FIXED	libhashfile.h	/^	FIXED = 1,$/;"	e	enum:chnking_method
HASH_FILE_MAGIC	libhashfile.h	142;"	d
HASH_FILE_VERSION1	libhashfile.h	150;"	d
HASH_FILE_VERSION2	libhashfile.h	151;"	d
HASH_FILE_VERSION3	libhashfile.h	152;"	d
HASH_FILE_VERSION4	libhashfile.h	153;"	d
HASH_FILE_VERSION5	libhashfile.h	154;"	d
HASH_FILE_VERSION6	libhashfile.h	155;"	d
HASH_FILE_VERSION7	libhashfile.h	156;"	d
MAX_PATH_SIZE	libhashfile.h	143;"	d
MAX_SYSID_LEN	libhashfile.h	144;"	d
MD5_48BIT_HASH	libhashfile.h	/^	MD5_48BIT_HASH = 3,$/;"	e	enum:hshing_method
MD5_64BIT_HASH	libhashfile.h	/^	MD5_64BIT_HASH = 5,$/;"	e	enum:hshing_method
MD5_HASH	libhashfile.h	/^	MD5_HASH = 1,$/;"	e	enum:hshing_method
MURMUR_HASH	libhashfile.h	/^	MURMUR_HASH = 4,$/;"	e	enum:hshing_method
NONE	libhashfile.h	/^	NONE = 0,$/;"	e	enum:cmpr_method
RABIN	libhashfile.h	/^	RABIN = 3$/;"	e	enum:var_chnking_algo
RANDOM	libhashfile.h	/^	RANDOM = 1,$/;"	e	enum:var_chnking_algo
READ	libhashfile.h	/^	READ = 0,$/;"	e	enum:openmode
SHA1_HASH	libhashfile.h	/^	SHA1_HASH = 6,$/;"	e	enum:hshing_method
SHA256_HASH	libhashfile.h	/^	SHA256_HASH = 2,$/;"	e	enum:hshing_method
SIMPLE_MATCH	libhashfile.h	/^	SIMPLE_MATCH = 2,$/;"	e	enum:var_chnking_algo
VARIABLE	libhashfile.h	/^	VARIABLE = 2$/;"	e	enum:chnking_method
WRITE	libhashfile.h	/^	WRITE = 1,$/;"	e	enum:openmode
ZLIB_DEF	libhashfile.h	/^	ZLIB_DEF = 1$/;"	e	enum:cmpr_method
_HASHFILELIB_H	libhashfile.h	17;"	d
abstract_file_header	libhashfile.h	/^struct abstract_file_header {$/;"	s
algo	libhashfile.h	/^	enum var_chnking_algo algo;$/;"	m	struct:var_chnking_params	typeref:enum:var_chnking_params::var_chnking_algo
algo_params	libhashfile.h	/^	} algo_params;$/;"	m	struct:var_chnking_params	typeref:union:var_chnking_params::__anon10
atime	libhashfile.h	/^	uint64_t atime;			\/* file atime *\/$/;"	m	struct:file_header_v3
atime	libhashfile.h	/^	uint64_t atime;			\/* file atime *\/$/;"	m	struct:file_header_v4
atime	libhashfile.h	/^	uint64_t atime;$/;"	m	struct:abstract_file_header
bits_to_compare	libhashfile.h	/^	uint32_t bits_to_compare;$/;"	m	struct:var_rabin_chnk_params
bits_to_compare	libhashfile.h	/^	uint32_t bits_to_compare;$/;"	m	struct:var_simple_chnk_params
blocks	libhashfile.h	/^	uint64_t blocks;		\/* 512B blocks allocated by fs *\/$/;"	m	struct:file_header_v4
blocks	libhashfile.h	/^	uint64_t blocks;$/;"	m	struct:abstract_file_header
bytes	libhashfile.h	/^	uint64_t bytes;$/;"	m	struct:header_v4
chnk_method	libhashfile.h	/^	enum chnking_method chnk_method;$/;"	m	struct:header	typeref:enum:header::chnking_method
chnk_method	libhashfile.h	/^	enum chnking_method chnk_method;$/;"	m	struct:header_v3	typeref:enum:header_v3::chnking_method
chnk_method	libhashfile.h	/^	enum chnking_method chnk_method;$/;"	m	struct:header_v4	typeref:enum:header_v4::chnking_method
chnk_method_params	libhashfile.h	/^	} chnk_method_params;$/;"	m	struct:header	typeref:union:header::__anon11
chnk_method_params	libhashfile.h	/^	} chnk_method_params;$/;"	m	struct:header_v3	typeref:union:header_v3::__anon12
chnk_method_params	libhashfile.h	/^	} chnk_method_params;$/;"	m	struct:header_v4	typeref:union:header_v4::__anon13
chnking_method	libhashfile.h	/^enum chnking_method$/;"	g
chunk_info	libhashfile.h	/^struct chunk_info {$/;"	s
chunk_size	libhashfile.h	/^	uint32_t chunk_size;$/;"	m	struct:fixed_chnking_params
chunks	libhashfile.h	/^	uint64_t chunks;		\/* chunks\/indexes in this file *\/$/;"	m	struct:file_header
chunks	libhashfile.h	/^	uint64_t chunks;		\/* chunks\/indexes in this file *\/$/;"	m	struct:file_header_v2
chunks	libhashfile.h	/^	uint64_t chunks;		\/* chunks\/indexes in this file *\/$/;"	m	struct:file_header_v3
chunks	libhashfile.h	/^	uint64_t chunks;		\/* chunks\/indexes in this file *\/$/;"	m	struct:file_header_v4
chunks	libhashfile.h	/^	uint64_t chunks; 		\/* number of chunks\/indexes *\/$/;"	m	struct:header
chunks	libhashfile.h	/^	uint64_t chunks; 		\/* number of chunks\/indexes *\/$/;"	m	struct:header_v3
chunks	libhashfile.h	/^	uint64_t chunks; 		\/* number of chunks\/indexes *\/$/;"	m	struct:header_v4
chunks	libhashfile.h	/^	uint64_t chunks;$/;"	m	struct:abstract_file_header
cmpr_method	libhashfile.h	/^enum cmpr_method$/;"	g
cratio	libhashfile.h	/^	uint8_t cratio;$/;"	m	struct:chunk_info
ctime	libhashfile.h	/^	uint64_t ctime;			\/* file ctime *\/$/;"	m	struct:file_header_v3
ctime	libhashfile.h	/^	uint64_t ctime;			\/* file ctime *\/$/;"	m	struct:file_header_v4
ctime	libhashfile.h	/^	uint64_t ctime;$/;"	m	struct:abstract_file_header
current_chunk_info	libhashfile.h	/^	struct chunk_info		current_chunk_info;$/;"	m	struct:hashfile_handle	typeref:struct:hashfile_handle::chunk_info
current_file	libhashfile.h	/^	struct abstract_file_header 	current_file;$/;"	m	struct:hashfile_handle	typeref:struct:hashfile_handle::abstract_file_header
current_file_header_offset	libhashfile.h	/^	off_t				current_file_header_offset;$/;"	m	struct:hashfile_handle
deviceid	libhashfile.h	/^	uint64_t deviceid;		\/* file device id *\/$/;"	m	struct:file_header_v3
deviceid	libhashfile.h	/^	uint64_t deviceid;		\/* file device id *\/$/;"	m	struct:file_header_v4
deviceid	libhashfile.h	/^	uint64_t deviceid;$/;"	m	struct:abstract_file_header
end_time	libhashfile.h	/^	uint64_t end_time;$/;"	m	struct:header_v3
end_time	libhashfile.h	/^	uint64_t end_time;$/;"	m	struct:header_v4
fd	libhashfile.h	/^	int 				fd;$/;"	m	struct:hashfile_handle
file_header	libhashfile.h	/^struct file_header {$/;"	s
file_header_v2	libhashfile.h	/^struct file_header_v2 {$/;"	s
file_header_v3	libhashfile.h	/^struct file_header_v3 {$/;"	s
file_header_v4	libhashfile.h	/^struct file_header_v4 {$/;"	s
file_size	libhashfile.h	/^	uint64_t file_size;		\/* in bytes *\/$/;"	m	struct:file_header
file_size	libhashfile.h	/^	uint64_t file_size;		\/* in bytes *\/$/;"	m	struct:file_header_v2
file_size	libhashfile.h	/^	uint64_t file_size;		\/* in bytes *\/$/;"	m	struct:file_header_v3
file_size	libhashfile.h	/^	uint64_t file_size;		\/* in bytes *\/$/;"	m	struct:file_header_v4
file_size	libhashfile.h	/^	uint64_t file_size;$/;"	m	struct:abstract_file_header
files	libhashfile.h	/^	uint64_t files;$/;"	m	struct:header
files	libhashfile.h	/^	uint64_t files;$/;"	m	struct:header_v3
files	libhashfile.h	/^	uint64_t files;$/;"	m	struct:header_v4
fixed_chnking_params	libhashfile.h	/^struct fixed_chnking_params$/;"	s
fixed_params	libhashfile.h	/^		struct fixed_chnking_params fixed_params;$/;"	m	union:header::__anon11	typeref:struct:header::__anon11::fixed_chnking_params
fixed_params	libhashfile.h	/^		struct fixed_chnking_params fixed_params;$/;"	m	union:header_v3::__anon12	typeref:struct:header_v3::__anon12::fixed_chnking_params
fixed_params	libhashfile.h	/^		struct fixed_chnking_params fixed_params;$/;"	m	union:header_v4::__anon13	typeref:struct:header_v4::__anon13::fixed_chnking_params
gid	libhashfile.h	/^	uint32_t gid;			\/* gid of file owner *\/$/;"	m	struct:file_header_v3
gid	libhashfile.h	/^	uint32_t gid;			\/* gid of file owner *\/$/;"	m	struct:file_header_v4
gid	libhashfile.h	/^	uint32_t gid;$/;"	m	struct:abstract_file_header
hardlinks	libhashfile.h	/^	uint64_t hardlinks;		\/* number of hardlinks *\/$/;"	m	struct:file_header_v3
hardlinks	libhashfile.h	/^	uint64_t hardlinks;		\/* number of hardlinks *\/$/;"	m	struct:file_header_v4
hardlinks	libhashfile.h	/^	uint64_t hardlinks;$/;"	m	struct:abstract_file_header
hash	libhashfile.h	/^	uint8_t *hash; \/* this points to static memory! *\/$/;"	m	struct:chunk_info
hash_size	libhashfile.h	/^	uint32_t hash_size;		\/* in bits *\/$/;"	m	struct:header
hash_size	libhashfile.h	/^	uint32_t hash_size;		\/* in bits *\/$/;"	m	struct:header_v3
hash_size	libhashfile.h	/^	uint32_t hash_size;		\/* in bits *\/$/;"	m	struct:header_v4
hashfile_handle	libhashfile.h	/^struct hashfile_handle {$/;"	s
header	libhashfile.h	/^	struct header_v4		header;$/;"	m	struct:hashfile_handle	typeref:struct:hashfile_handle::header_v4
header	libhashfile.h	/^struct header {$/;"	s
header_v3	libhashfile.h	/^struct header_v3 {$/;"	s
header_v4	libhashfile.h	/^struct header_v4 {$/;"	s
hsh_method	libhashfile.h	/^	enum hshing_method hsh_method;$/;"	m	struct:header	typeref:enum:header::hshing_method
hsh_method	libhashfile.h	/^	enum hshing_method hsh_method;$/;"	m	struct:header_v3	typeref:enum:header_v3::hshing_method
hsh_method	libhashfile.h	/^	enum hshing_method hsh_method;$/;"	m	struct:header_v4	typeref:enum:header_v4::hshing_method
hshing_method	libhashfile.h	/^enum hshing_method$/;"	g
inodenum	libhashfile.h	/^	uint64_t inodenum;		\/* file inode number *\/$/;"	m	struct:file_header_v3
inodenum	libhashfile.h	/^	uint64_t inodenum;		\/* file inode number *\/$/;"	m	struct:file_header_v4
inodenum	libhashfile.h	/^	uint64_t inodenum;$/;"	m	struct:abstract_file_header
magic	libhashfile.h	/^	uint32_t magic;$/;"	m	struct:header
magic	libhashfile.h	/^	uint32_t magic;$/;"	m	struct:header_v3
magic	libhashfile.h	/^	uint32_t magic;$/;"	m	struct:header_v4
max_csize	libhashfile.h	/^	uint32_t max_csize;		\/* in bytes *\/$/;"	m	struct:var_chnking_params
min_csize	libhashfile.h	/^	uint32_t min_csize;		\/* in bytes *\/$/;"	m	struct:var_chnking_params
module	libhashfile.h	/^	uint64_t module;$/;"	m	struct:var_rabin_chnk_params
mtime	libhashfile.h	/^	uint64_t mtime;			\/* file mtime *\/$/;"	m	struct:file_header_v3
mtime	libhashfile.h	/^	uint64_t mtime;			\/* file mtime *\/$/;"	m	struct:file_header_v4
mtime	libhashfile.h	/^	uint64_t mtime;$/;"	m	struct:abstract_file_header
num_files_processed	libhashfile.h	/^	uint64_t			num_files_processed;$/;"	m	struct:hashfile_handle
num_hashes_processed_current_file	libhashfile.h	/^	uint64_t			num_hashes_processed_current_file;$/;"	m	struct:hashfile_handle
omode	libhashfile.h	/^	enum openmode			omode;$/;"	m	struct:hashfile_handle	typeref:enum:hashfile_handle::openmode
openmode	libhashfile.h	/^enum openmode {$/;"	g
path	libhashfile.h	/^	char path[0];			\/* non-null terminated path$/;"	m	struct:file_header_v2
path	libhashfile.h	/^	char path[0];			\/* non-null terminated path$/;"	m	struct:file_header_v3
path	libhashfile.h	/^	char path[0];			\/* non-null terminated path$/;"	m	struct:file_header_v4
path	libhashfile.h	/^	char path[MAX_PATH_SIZE];$/;"	m	struct:abstract_file_header
path	libhashfile.h	/^	char path[MAX_PATH_SIZE];$/;"	m	struct:file_header
path_root	libhashfile.h	/^	char path_root[MAX_PATH_SIZE];	\/* where the scan has started *\/$/;"	m	struct:header
path_root	libhashfile.h	/^	char path_root[MAX_PATH_SIZE];	\/* where the scan has started *\/$/;"	m	struct:header_v3
path_root	libhashfile.h	/^	char path_root[MAX_PATH_SIZE];	\/* where the scan has started *\/$/;"	m	struct:header_v4
pathlen	libhashfile.h	/^	uint32_t pathlen;		\/* length of the following path *\/$/;"	m	struct:file_header_v2
pathlen	libhashfile.h	/^	uint32_t pathlen;		\/* length of the following path *\/$/;"	m	struct:file_header_v3
pathlen	libhashfile.h	/^	uint32_t pathlen;		\/* length of the following path *\/$/;"	m	struct:file_header_v4
pathlen	libhashfile.h	/^	uint32_t pathlen;$/;"	m	struct:abstract_file_header
pattern	libhashfile.h	/^	uint64_t pattern;$/;"	m	struct:var_rabin_chnk_params
pattern	libhashfile.h	/^	uint64_t pattern;$/;"	m	struct:var_simple_chnk_params
perm	libhashfile.h	/^	uint64_t perm;			\/* file mode *\/$/;"	m	struct:file_header_v3
perm	libhashfile.h	/^	uint64_t perm;			\/* file mode *\/$/;"	m	struct:file_header_v4
perm	libhashfile.h	/^	uint64_t perm;$/;"	m	struct:abstract_file_header
prime	libhashfile.h	/^	uint64_t prime;$/;"	m	struct:var_rabin_chnk_params
probability	libhashfile.h	/^	long double probability;	\/* probability to chunk a stream *\/$/;"	m	struct:var_random_chnk_params
rabin_params	libhashfile.h	/^		struct var_rabin_chnk_params rabin_params;$/;"	m	union:var_chnking_params::__anon10	typeref:struct:var_chnking_params::__anon10::var_rabin_chnk_params
rnd_params	libhashfile.h	/^		struct var_random_chnk_params rnd_params;$/;"	m	union:var_chnking_params::__anon10	typeref:struct:var_chnking_params::__anon10::var_random_chnk_params
simple_params	libhashfile.h	/^		struct var_simple_chnk_params simple_params;$/;"	m	union:var_chnking_params::__anon10	typeref:struct:var_chnking_params::__anon10::var_simple_chnk_params
size	libhashfile.h	/^	uint64_t size;$/;"	m	struct:chunk_info
start_time	libhashfile.h	/^	uint64_t start_time;$/;"	m	struct:header_v3
start_time	libhashfile.h	/^	uint64_t start_time;$/;"	m	struct:header_v4
sysid	libhashfile.h	/^	char sysid[MAX_SYSID_LEN];$/;"	m	struct:header_v3
sysid	libhashfile.h	/^	char sysid[MAX_SYSID_LEN];$/;"	m	struct:header_v4
target_path	libhashfile.h	/^	char target_path[0];		\/* non-null terminated$/;"	m	struct:file_header_v3
target_path	libhashfile.h	/^	char target_path[0];		\/* non-null terminated$/;"	m	struct:file_header_v4
target_path	libhashfile.h	/^	char target_path[MAX_PATH_SIZE];$/;"	m	struct:abstract_file_header
target_pathlen	libhashfile.h	/^	uint32_t target_pathlen;	\/* length of the following target_path *\/$/;"	m	struct:file_header_v3
target_pathlen	libhashfile.h	/^	uint32_t target_pathlen;	\/* length of the following target_path *\/$/;"	m	struct:file_header_v4
target_pathlen	libhashfile.h	/^	uint32_t target_pathlen;$/;"	m	struct:abstract_file_header
uid	libhashfile.h	/^	uint32_t uid;			\/* uid of file owner *\/$/;"	m	struct:file_header_v3
uid	libhashfile.h	/^	uint32_t uid;			\/* uid of file owner *\/$/;"	m	struct:file_header_v4
uid	libhashfile.h	/^	uint32_t uid;$/;"	m	struct:abstract_file_header
var_chnking_algo	libhashfile.h	/^enum var_chnking_algo$/;"	g
var_chnking_params	libhashfile.h	/^struct var_chnking_params$/;"	s
var_params	libhashfile.h	/^		struct var_chnking_params var_params;$/;"	m	union:header::__anon11	typeref:struct:header::__anon11::var_chnking_params
var_params	libhashfile.h	/^		struct var_chnking_params var_params;$/;"	m	union:header_v3::__anon12	typeref:struct:header_v3::__anon12::var_chnking_params
var_params	libhashfile.h	/^		struct var_chnking_params var_params;$/;"	m	union:header_v4::__anon13	typeref:struct:header_v4::__anon13::var_chnking_params
var_rabin_chnk_params	libhashfile.h	/^struct var_rabin_chnk_params {$/;"	s
var_random_chnk_params	libhashfile.h	/^struct var_random_chnk_params {$/;"	s
var_simple_chnk_params	libhashfile.h	/^struct var_simple_chnk_params {$/;"	s
version	libhashfile.h	/^	uint32_t version;$/;"	m	struct:header
version	libhashfile.h	/^	uint32_t version;$/;"	m	struct:header_v3
version	libhashfile.h	/^	uint32_t version;$/;"	m	struct:header_v4
window_size	libhashfile.h	/^	uint32_t window_size; 		\/* in bytes *\/$/;"	m	struct:var_rabin_chnk_params
free_lru_cache	lru_cache.cpp	/^void free_lru_cache(struct lruCache* c) {$/;"	f
lru_cache_hits	lru_cache.cpp	/^void* lru_cache_hits(struct lruCache* c, void* user_data,$/;"	f
lru_cache_insert	lru_cache.cpp	/^void lru_cache_insert(struct lruCache *c, void* data,$/;"	f
lru_cache_is_full	lru_cache.cpp	/^int lru_cache_is_full(struct lruCache* c) {$/;"	f
lru_cache_kicks	lru_cache.cpp	/^void lru_cache_kicks(struct lruCache* c, void* user_data,$/;"	f
lru_cache_lookup	lru_cache.cpp	/^void* lru_cache_lookup(struct lruCache* c, void* user_data) {$/;"	f
lru_cache_lookup_without_update	lru_cache.cpp	/^void* lru_cache_lookup_without_update(struct lruCache* c, void* user_data) {$/;"	f
new_lru_cache	lru_cache.cpp	/^struct lruCache* new_lru_cache(int size, void (*free_elem)(void *),$/;"	f
Cache_H_	lru_cache.h	9;"	d
INFI_CACHE	lru_cache.h	10;"	d
elem_queue	lru_cache.h	/^	GList *elem_queue;$/;"	m	struct:lruCache
free_elem	lru_cache.h	/^	void (*free_elem)(void *);$/;"	m	struct:lruCache
hit_count	lru_cache.h	/^	double hit_count;$/;"	m	struct:lruCache
hit_elem	lru_cache.h	/^	int (*hit_elem)(void* elem, void* user_data);$/;"	m	struct:lruCache
lruCache	lru_cache.h	/^struct lruCache {$/;"	s
max_size	lru_cache.h	/^	int max_size; \/\/ less then zero means infinite cache$/;"	m	struct:lruCache
miss_count	lru_cache.h	/^	double miss_count;$/;"	m	struct:lruCache
size	lru_cache.h	/^	int size;$/;"	m	struct:lruCache
accessRecords	optimal_restore.cpp	/^struct accessRecords {$/;"	s	file:
access_record_table	optimal_restore.cpp	/^	GHashTable *access_record_table;$/;"	m	struct:__anon14	file:
buffered_access_record_num	optimal_restore.cpp	/^	int buffered_access_record_num;$/;"	m	struct:__anon14	file:
cid	optimal_restore.cpp	/^	containerid cid;$/;"	m	struct:accessRecords	file:
current_sequence_number	optimal_restore.cpp	/^	int current_sequence_number;$/;"	m	struct:__anon14	file:
find_kicked_container	optimal_restore.cpp	/^static int find_kicked_container(void *con1, void *ht1) {$/;"	f	file:
find_kicked_container_meta	optimal_restore.cpp	/^static int find_kicked_container_meta(void *cm1, void *ht1) {$/;"	f	file:
free_access_records	optimal_restore.cpp	/^static void free_access_records(struct accessRecords* r) {$/;"	f	file:
g_access_records_cmp_by_first_seqno	optimal_restore.cpp	/^static gint g_access_records_cmp_by_first_seqno(struct accessRecords *a,$/;"	f	file:
init_optimal_cache	optimal_restore.cpp	/^void init_optimal_cache() {$/;"	f
lru_queue	optimal_restore.cpp	/^	struct lruCache *lru_queue;$/;"	m	struct:__anon14	typeref:struct:__anon14::lruCache	file:
new_access_records	optimal_restore.cpp	/^static struct accessRecords* new_access_records(containerid id) {$/;"	f	file:
optimal_cache	optimal_restore.cpp	/^} optimal_cache;$/;"	v	typeref:struct:__anon14
optimal_cache_hits	optimal_restore.cpp	/^static int optimal_cache_hits(containerid id) {$/;"	f	file:
optimal_cache_insert	optimal_restore.cpp	/^static void optimal_cache_insert(containerid id) {$/;"	f	file:
optimal_cache_lookup	optimal_restore.cpp	/^static struct chunk* optimal_cache_lookup(fingerprint *fp) {$/;"	f	file:
optimal_cache_window_fill	optimal_restore.cpp	/^static void optimal_cache_window_fill() {$/;"	f	file:
optimal_cache_window_slides	optimal_restore.cpp	/^static void optimal_cache_window_slides(containerid id) {$/;"	f	file:
optimal_restore_thread	optimal_restore.cpp	/^void* optimal_restore_thread(void *arg) {$/;"	f
seqno_queue	optimal_restore.cpp	/^	GQueue *seqno_queue;$/;"	m	struct:accessRecords	file:
sorted_records_of_cached_containers	optimal_restore.cpp	/^	GSequence *sorted_records_of_cached_containers;$/;"	m	struct:__anon14	file:
victim	optimal_restore.cpp	/^struct accessRecords* victim;$/;"	v	typeref:struct:accessRecords
queue_empty	queue.cpp	/^void queue_empty(Queue *queue, void (*free_data)(void*)) {$/;"	f
queue_find	queue.cpp	/^void* queue_find(Queue* queue, int (*hit)(void*, void*), void* data) {$/;"	f
queue_foreach	queue.cpp	/^void queue_foreach(Queue *queue, void (*func)(void *data, void *user_data),$/;"	f
queue_free	queue.cpp	/^void queue_free(Queue *queue, void (*free_data)(void*)) {$/;"	f
queue_get_n	queue.cpp	/^void* queue_get_n(Queue *queue, int n) {$/;"	f
queue_init	queue.cpp	/^void queue_init(Queue *queue) {$/;"	f
queue_new	queue.cpp	/^Queue* queue_new() {$/;"	f
queue_pop	queue.cpp	/^void* queue_pop(Queue *queue) {$/;"	f
queue_push	queue.cpp	/^void queue_push(Queue *queue, void *element) {$/;"	f
queue_size	queue.cpp	/^int queue_size(Queue *queue) {$/;"	f
queue_top	queue.cpp	/^void * queue_top(Queue *queue) {$/;"	f
QUEUE_H_	queue.h	9;"	d
Queue	queue.h	/^} Queue;$/;"	t	typeref:struct:queue_tag
data	queue.h	/^	void *data;$/;"	m	struct:queue_ele_tag
elem_num	queue.h	/^	int elem_num;$/;"	m	struct:queue_tag
first	queue.h	/^	queue_ele_t *first, *last; \/* work queue *\/$/;"	m	struct:queue_tag
last	queue.h	/^	queue_ele_t *first, *last; \/* work queue *\/$/;"	m	struct:queue_tag
next	queue.h	/^	struct queue_ele_tag *next;$/;"	m	struct:queue_ele_tag	typeref:struct:queue_ele_tag::queue_ele_tag
queue_ele_t	queue.h	/^} queue_ele_t;$/;"	t	typeref:struct:queue_ele_tag
queue_ele_tag	queue.h	/^typedef struct queue_ele_tag {$/;"	s
queue_tag	queue.h	/^typedef struct queue_tag {$/;"	s
BREAKMARK_VALUE	rabin_chunking.cpp	7;"	d	file:
FINGERPRINT_PT	rabin_chunking.cpp	6;"	d	file:
MAXBUF	rabin_chunking.cpp	4;"	d	file:
MSB64	rabin_chunking.cpp	3;"	d	file:
SLIDE	rabin_chunking.cpp	9;"	d	file:
T	rabin_chunking.cpp	/^UINT64 T[256];$/;"	v
U	rabin_chunking.cpp	/^UINT64 U[256];$/;"	v
UINT32	rabin_chunking.cpp	/^typedef unsigned int UINT32;$/;"	t	file:
UINT64	rabin_chunking.cpp	/^typedef unsigned long long int UINT64;$/;"	t	file:
_cur_pos	rabin_chunking.cpp	/^size_t _cur_pos;$/;"	v
_last_pos	rabin_chunking.cpp	/^size_t _last_pos;$/;"	v
_num_chunks	rabin_chunking.cpp	/^unsigned int _num_chunks;$/;"	v
append8	rabin_chunking.cpp	/^UINT64 append8(UINT64 p, unsigned char m) {$/;"	f
buf	rabin_chunking.cpp	/^unsigned char buf[size];$/;"	v
bufpos	rabin_chunking.cpp	/^int bufpos;$/;"	v
bytemsb	rabin_chunking.cpp	/^const char bytemsb[0x100] = { 0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5,$/;"	v
calcT	rabin_chunking.cpp	/^void calcT(UINT64 poly) {$/;"	f
chunkAlg_init	rabin_chunking.cpp	/^void chunkAlg_init() {$/;"	f
eFiles	rabin_chunking.cpp	/^char *eFiles[] = { ".pdf", ".rmv", "ra", ".bmp", ".vmem", ".vmdk", ".jpeg",$/;"	v
fls32	rabin_chunking.cpp	/^static uint32_t fls32(UINT32 v) {$/;"	f	file:
fls64	rabin_chunking.cpp	/^static uint32_t fls64(UINT64 v) {$/;"	f	file:
fp	rabin_chunking.cpp	/^UINT64 fp;$/;"	v
normalized_rabin_chunk_data	rabin_chunking.cpp	/^int normalized_rabin_chunk_data(unsigned char *p, int n) {$/;"	f
poly	rabin_chunking.cpp	/^UINT64 poly;$/;"	v
polymmult	rabin_chunking.cpp	/^UINT64 polymmult(UINT64 x, UINT64 y, UINT64 d) {$/;"	f
polymod	rabin_chunking.cpp	/^UINT64 polymod(UINT64 nh, UINT64 nl, UINT64 d) {$/;"	f
polymult	rabin_chunking.cpp	/^void polymult(UINT64 *php, UINT64 *plp, UINT64 x, UINT64 y) {$/;"	f
rabin_chunk_data	rabin_chunking.cpp	/^int rabin_chunk_data(unsigned char *p, int n) {$/;"	f
rabin_mask	rabin_chunking.cpp	/^static int rabin_mask = 0;$/;"	v	file:
rabinpoly_init	rabin_chunking.cpp	/^void rabinpoly_init(UINT64 p) {$/;"	f
shift	rabin_chunking.cpp	/^int shift;$/;"	v
size	rabin_chunking.cpp	/^	size = 48$/;"	e	enum:__anon15	file:
slide8	rabin_chunking.cpp	/^UINT64 slide8(unsigned char m) {$/;"	f
tttd_chunk_data	rabin_chunking.cpp	/^int tttd_chunk_data(unsigned char *p, int n) {$/;"	f
window_init	rabin_chunking.cpp	/^void window_init(UINT64 poly) {$/;"	f
windows_reset	rabin_chunking.cpp	/^void windows_reset() {$/;"	f
MAXLINE	read_fsl_trace.cpp	35;"	d	file:
print_chunk_hash	read_fsl_trace.cpp	/^static void print_chunk_hash(uint64_t chunk_count, const uint8_t *hash,$/;"	f	file:
read_fsl_trace	read_fsl_trace.cpp	/^void* read_fsl_trace(void *argv)$/;"	f
find_one_file	read_phase.cpp	/^static void find_one_file(sds path) {$/;"	f	file:
read_file	read_phase.cpp	/^static void read_file(sds path) {$/;"	f	file:
read_queue	read_phase.cpp	/^SyncQueue* read_queue;$/;"	v
read_t	read_phase.cpp	/^static pthread_t read_t;$/;"	v	file:
read_thread	read_phase.cpp	/^static void* read_thread(void *argv) {$/;"	f	file:
start_read_phase	read_phase.cpp	/^void start_read_phase() {$/;"	f
stop_read_phase	read_phase.cpp	/^void stop_read_phase() {$/;"	f
access_record	recipestore.cpp	/^static containerid access_record = TEMPORARY_ID;$/;"	v	file:
append_file_recipe_meta	recipestore.cpp	/^void append_file_recipe_meta(struct backupVersion* b, struct fileRecipeMeta* r) {$/;"	f
append_n_chunk_pointers	recipestore.cpp	/^void append_n_chunk_pointers(struct backupVersion* b,$/;"	f
append_segment_flag	recipestore.cpp	/^segmentid append_segment_flag(struct backupVersion* b, int flag, int segment_size){$/;"	f
backup_version_count	recipestore.cpp	/^static int32_t backup_version_count;$/;"	v	file:
backup_version_exists	recipestore.cpp	/^int backup_version_exists(int number) {$/;"	f
close_recipe_store	recipestore.cpp	/^void close_recipe_store() {$/;"	f
create_backup_version	recipestore.cpp	/^struct backupVersion* create_backup_version(const char *path) {$/;"	f
free_backup_version	recipestore.cpp	/^void free_backup_version(struct backupVersion *b) {$/;"	f
free_file_recipe_meta	recipestore.cpp	/^void free_file_recipe_meta(struct fileRecipeMeta* r) {$/;"	f
free_segment_recipe	recipestore.cpp	/^void free_segment_recipe(struct segmentRecipe* sr) {$/;"	f
get_next_version_number	recipestore.cpp	/^int32_t get_next_version_number() {$/;"	f
id_to_bnum	recipestore.cpp	/^static inline int64_t id_to_bnum(segmentid id) {$/;"	f	file:
id_to_off	recipestore.cpp	/^static inline int64_t id_to_off(segmentid id) {$/;"	f	file:
id_to_size	recipestore.cpp	/^static inline int64_t id_to_size(segmentid id) {$/;"	f	file:
init_recipe_store	recipestore.cpp	/^void init_recipe_store() {$/;"	f
lookup_fingerprint_in_segment_recipe	recipestore.cpp	/^int lookup_fingerprint_in_segment_recipe(struct segmentRecipe* sr,$/;"	f
make_segment_id	recipestore.cpp	/^static inline segmentid make_segment_id(int64_t bid, int64_t off, int64_t size){$/;"	f	file:
metabufsize	recipestore.cpp	/^static int metabufsize = 64*1024;$/;"	v	file:
new_file_recipe_meta	recipestore.cpp	/^struct fileRecipeMeta* new_file_recipe_meta(char* name) {$/;"	f
new_segment_recipe	recipestore.cpp	/^struct segmentRecipe* new_segment_recipe() {$/;"	f
open_backup_version	recipestore.cpp	/^struct backupVersion* open_backup_version(int number) {$/;"	f
prefetch_segments	recipestore.cpp	/^GQueue* prefetch_segments(segmentid id, int prefetch_num) {$/;"	f
read_next_file_recipe_meta	recipestore.cpp	/^struct fileRecipeMeta* read_next_file_recipe_meta(struct backupVersion* b) {$/;"	f
read_next_n_chunk_pointers	recipestore.cpp	/^struct chunkPointer* read_next_n_chunk_pointers(struct backupVersion* b, int n,$/;"	f
read_next_n_records	recipestore.cpp	/^containerid* read_next_n_records(struct backupVersion* b, int n, int *k) {$/;"	f
read_next_segment	recipestore.cpp	/^struct segmentRecipe* read_next_segment(struct backupVersion *bv){$/;"	f
recipepath	recipestore.cpp	/^static sds recipepath;$/;"	v	file:
recordbufsize	recipestore.cpp	/^static int recordbufsize = 64*1024;$/;"	v	file:
segment_recipe_check_id	recipestore.cpp	/^int segment_recipe_check_id(struct segmentRecipe* sr, segmentid *id) {$/;"	f
segment_recipe_foreach	recipestore.cpp	/^void segment_recipe_foreach(struct segmentRecipe* sr, void (*func)(fingerprint*, void*), void* data){$/;"	f
update_backup_version	recipestore.cpp	/^void update_backup_version(struct backupVersion *b) {$/;"	f
RECIPESTORE_H_	recipestore.h	9;"	d
backupVersion	recipestore.h	/^struct backupVersion {$/;"	s
bv_num	recipestore.h	/^	int32_t bv_num; \/* backup version number start from 0 *\/$/;"	m	struct:backupVersion
chunkPointer	recipestore.h	/^struct chunkPointer {$/;"	s
chunknum	recipestore.h	/^	int64_t chunknum;$/;"	m	struct:fileRecipeMeta
deleted	recipestore.h	/^	int deleted;$/;"	m	struct:backupVersion
fileRecipeMeta	recipestore.h	/^struct fileRecipeMeta {$/;"	s
filename	recipestore.h	/^	sds filename;$/;"	m	struct:fileRecipeMeta
filesize	recipestore.h	/^	int64_t filesize;$/;"	m	struct:fileRecipeMeta
fname_prefix	recipestore.h	/^	sds fname_prefix; \/* The prefix of the file names *\/$/;"	m	struct:backupVersion
fp	recipestore.h	/^	fingerprint fp;$/;"	m	struct:chunkPointer
id	recipestore.h	/^	containerid id;$/;"	m	struct:chunkPointer
id	recipestore.h	/^	segmentid id;$/;"	m	struct:segmentRecipe
kvpairs	recipestore.h	/^	GHashTable *kvpairs;$/;"	m	struct:segmentRecipe
metabuf	recipestore.h	/^	char *metabuf;$/;"	m	struct:backupVersion
metabufoff	recipestore.h	/^	int metabufoff;$/;"	m	struct:backupVersion
metadata_fp	recipestore.h	/^	FILE *metadata_fp;$/;"	m	struct:backupVersion
number_of_chunks	recipestore.h	/^	int64_t number_of_chunks;$/;"	m	struct:backupVersion
number_of_files	recipestore.h	/^	int64_t number_of_files;$/;"	m	struct:backupVersion
path	recipestore.h	/^	sds path;$/;"	m	struct:backupVersion
recipe_fp	recipestore.h	/^	FILE *recipe_fp;$/;"	m	struct:backupVersion
record_fp	recipestore.h	/^	FILE *record_fp;$/;"	m	struct:backupVersion
recordbuf	recipestore.h	/^	char *recordbuf;$/;"	m	struct:backupVersion
recordbufoff	recipestore.h	/^	int recordbufoff;$/;"	m	struct:backupVersion
segmentRecipe	recipestore.h	/^struct segmentRecipe {$/;"	s
segmentbuf	recipestore.h	/^	char* segmentbuf;$/;"	m	struct:backupVersion
segmentbufoff	recipestore.h	/^	int segmentbufoff;$/;"	m	struct:backupVersion
segmentlen	recipestore.h	/^	int segmentlen;$/;"	m	struct:backupVersion
size	recipestore.h	/^	int32_t size;$/;"	m	struct:chunkPointer
RESTORE_H_	restore.h	9;"	d
cache	restore_aware.cpp	/^	struct lruCache *cache;$/;"	m	struct:__anon16	typeref:struct:__anon16::lruCache	file:
ccf	restore_aware.cpp	/^	int ccf;$/;"	m	struct:__anon16	file:
cfl	restore_aware.cpp	/^	double cfl; \/\/ocf\/ccf$/;"	m	struct:__anon16	file:
container_record_check_id	restore_aware.cpp	/^static int container_record_check_id(void *a1, void *id1) {$/;"	f	file:
init_restore_aware	restore_aware.cpp	/^void init_restore_aware() {$/;"	f
monitor	restore_aware.cpp	/^} monitor;$/;"	v	typeref:struct:__anon16
ocf	restore_aware.cpp	/^	int ocf; \/\/data amount\/CONTAINER_SIZE$/;"	m	struct:__anon16	file:
restore_aware_contains	restore_aware.cpp	/^int restore_aware_contains(containerid id) {$/;"	f
restore_aware_get_cfl	restore_aware.cpp	/^double restore_aware_get_cfl() {$/;"	f
restore_aware_update	restore_aware.cpp	/^void restore_aware_update(containerid id, int32_t chunklen) {$/;"	f
total_size	restore_aware.cpp	/^	int64_t total_size;$/;"	m	struct:__anon16	file:
g_record_cmp_by_id	rewrite_phase.cpp	/^gint g_record_cmp_by_id(struct containerRecord* a, struct containerRecord* b,$/;"	f
g_record_descmp_by_length	rewrite_phase.cpp	/^gint g_record_descmp_by_length(struct containerRecord* a,$/;"	f
init_rewrite_buffer	rewrite_phase.cpp	/^static void init_rewrite_buffer() {$/;"	f	file:
no_rewrite	rewrite_phase.cpp	/^static void* no_rewrite(void* arg) {$/;"	f	file:
rewrite_buffer_pop	rewrite_phase.cpp	/^struct chunk* rewrite_buffer_pop() {$/;"	f
rewrite_buffer_push	rewrite_phase.cpp	/^int rewrite_buffer_push(struct chunk* c) {$/;"	f
rewrite_buffer_top	rewrite_phase.cpp	/^struct chunk* rewrite_buffer_top() {$/;"	f
rewrite_queue	rewrite_phase.cpp	/^SyncQueue* rewrite_queue;$/;"	v
rewrite_t	rewrite_phase.cpp	/^static pthread_t rewrite_t;$/;"	v	file:
start_rewrite_phase	rewrite_phase.cpp	/^void start_rewrite_phase() {$/;"	f
stop_rewrite_phase	rewrite_phase.cpp	/^void stop_rewrite_phase() {$/;"	f
REWRITE_PHASE_H_	rewrite_phase.h	9;"	d
chunk_queue	rewrite_phase.h	/^	GQueue *chunk_queue;$/;"	m	struct:__anon17
cid	rewrite_phase.h	/^	containerid cid;$/;"	m	struct:containerRecord
containerRecord	rewrite_phase.h	/^struct containerRecord {$/;"	s
container_record_seq	rewrite_phase.h	/^	GSequence *container_record_seq; \/\/$/;"	m	struct:__anon17
num	rewrite_phase.h	/^	int num;$/;"	m	struct:__anon17
out_of_order	rewrite_phase.h	/^	int32_t out_of_order;$/;"	m	struct:containerRecord
rewrite_buffer	rewrite_phase.h	/^} rewrite_buffer;$/;"	v	typeref:struct:__anon17
size	rewrite_phase.h	/^	int size;$/;"	m	struct:__anon17
size	rewrite_phase.h	/^	int32_t size;$/;"	m	struct:containerRecord
index_sampling_min	sampling_method.cpp	/^static GHashTable* index_sampling_min(GSequence *chunks, int32_t chunk_num) {$/;"	f	file:
index_sampling_optimized_min	sampling_method.cpp	/^static GHashTable* index_sampling_optimized_min(GSequence *chunks,$/;"	f	file:
index_sampling_random	sampling_method.cpp	/^static GHashTable* index_sampling_random(GSequence *chunks, int32_t chunk_num) {$/;"	f	file:
index_sampling_uniform	sampling_method.cpp	/^static GHashTable* index_sampling_uniform(GSequence *chunks, int32_t chunk_num) {$/;"	f	file:
init_sampling_method	sampling_method.cpp	/^void init_sampling_method(){$/;"	f
sampling	sampling_method.cpp	/^GHashTable* (*sampling)(GSequence *chunks, int32_t chunk_num);$/;"	v
hex_digit_to_int	sds.cpp	/^int hex_digit_to_int(char c) {$/;"	f
is_hex_digit	sds.cpp	/^int is_hex_digit(char c) {$/;"	f
main	sds.cpp	/^int main(void) {$/;"	f
sdsAllocSize	sds.cpp	/^size_t sdsAllocSize(sds s) {$/;"	f
sdsIncrLen	sds.cpp	/^void sdsIncrLen(sds s, int incr) {$/;"	f
sdsMakeRoomFor	sds.cpp	/^sds sdsMakeRoomFor(sds s, size_t addlen) {$/;"	f
sdsRemoveFreeSpace	sds.cpp	/^sds sdsRemoveFreeSpace(sds s) {$/;"	f
sdscat	sds.cpp	/^sds sdscat(sds s, const char *t) {$/;"	f
sdscatlen	sds.cpp	/^sds sdscatlen(sds s, const void *t, size_t len) {$/;"	f
sdscatprintf	sds.cpp	/^sds sdscatprintf(sds s, const char *fmt, ...) {$/;"	f
sdscatrepr	sds.cpp	/^sds sdscatrepr(sds s, const char *p, size_t len) {$/;"	f
sdscatsds	sds.cpp	/^sds sdscatsds(sds s, const sds t) {$/;"	f
sdscatvprintf	sds.cpp	/^sds sdscatvprintf(sds s, const char *fmt, va_list ap) {$/;"	f
sdsclear	sds.cpp	/^void sdsclear(sds s) {$/;"	f
sdscmp	sds.cpp	/^int sdscmp(const sds s1, const sds s2) {$/;"	f
sdscpy	sds.cpp	/^sds sdscpy(sds s, const char *t) {$/;"	f
sdscpylen	sds.cpp	/^sds sdscpylen(sds s, const char *t, size_t len) {$/;"	f
sdsdup	sds.cpp	/^sds sdsdup(const sds s) {$/;"	f
sdsempty	sds.cpp	/^sds sdsempty(void) {$/;"	f
sdsfree	sds.cpp	/^void sdsfree(sds s) {$/;"	f
sdsfreesplitres	sds.cpp	/^void sdsfreesplitres(sds *tokens, int count) {$/;"	f
sdsfromlonglong	sds.cpp	/^sds sdsfromlonglong(long long value) {$/;"	f
sdsgrowzero	sds.cpp	/^sds sdsgrowzero(sds s, size_t len) {$/;"	f
sdsjoin	sds.cpp	/^sds sdsjoin(char **argv, int argc, char *sep) {$/;"	f
sdsmapchars	sds.cpp	/^sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {$/;"	f
sdsnew	sds.cpp	/^sds sdsnew(const char *init) {$/;"	f
sdsnewlen	sds.cpp	/^sds sdsnewlen(const void *init, size_t initlen) {$/;"	f
sdsrange	sds.cpp	/^void sdsrange(sds s, int start, int end) {$/;"	f
sdssplitargs	sds.cpp	/^sds *sdssplitargs(const char *line, int *argc) {$/;"	f
sdssplitlen	sds.cpp	/^sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count) {$/;"	f
sdstolower	sds.cpp	/^void sdstolower(sds s) {$/;"	f
sdstoupper	sds.cpp	/^void sdstoupper(sds s) {$/;"	f
sdstrim	sds.cpp	/^sds sdstrim(sds s, const char *cset) {$/;"	f
sdsupdatelen	sds.cpp	/^void sdsupdatelen(sds s) {$/;"	f
SDS_MAX_PREALLOC	sds.h	34;"	d
__SDS_H	sds.h	32;"	d
buf	sds.h	/^    char buf[];$/;"	m	struct:sdshdr
free	sds.h	/^    int free;$/;"	m	struct:sdshdr
len	sds.h	/^    int len;$/;"	m	struct:sdshdr
sds	sds.h	/^typedef char *sds;$/;"	t
sdsavail	sds.h	/^static inline size_t sdsavail(const sds s) {$/;"	f
sdshdr	sds.h	/^struct sdshdr {$/;"	s
sdslen	sds.h	/^static inline size_t sdslen(const sds s) {$/;"	f
init_segmenting_method	segmenting_method.cpp	/^void init_segmenting_method(){$/;"	f
segment_content_defined	segmenting_method.cpp	/^static struct segment* segment_content_defined(struct chunk *c) {$/;"	f	file:
segment_file_defined	segmenting_method.cpp	/^static struct segment* segment_file_defined(struct chunk *c) {$/;"	f	file:
segment_fixed	segmenting_method.cpp	/^static struct segment* segment_fixed(struct chunk * c) {$/;"	f	file:
segmenting	segmenting_method.cpp	/^struct segment* (*segmenting)(struct chunk *c);$/;"	v	typeref:struct:segmenting
serial_int16	serial.cpp	/^void serial_int16(uint8_t * * const ptr, const int16_t v)$/;"	f
serial_int32	serial.cpp	/^void serial_int32(uint8_t * * const ptr, const int32_t v)$/;"	f
serial_int64	serial.cpp	/^void serial_int64(uint8_t * * const ptr, const int64_t v)$/;"	f
serial_string	serial.cpp	/^void serial_string(uint8_t * * const ptr, const char * const str)$/;"	f
serial_uint16	serial.cpp	/^void serial_uint16(uint8_t * * const ptr, const uint16_t v)$/;"	f
serial_uint32	serial.cpp	/^void serial_uint32(uint8_t * * const ptr, const uint32_t v)$/;"	f
serial_uint64	serial.cpp	/^void serial_uint64(uint8_t * * const ptr, const uint64_t v)$/;"	f
unserial_int16	serial.cpp	/^int16_t unserial_int16(uint8_t * * const ptr)$/;"	f
unserial_int32	serial.cpp	/^int32_t unserial_int32(uint8_t * * const ptr)$/;"	f
unserial_int64	serial.cpp	/^int64_t unserial_int64(uint8_t * * const ptr)$/;"	f
unserial_string	serial.cpp	/^void unserial_string(uint8_t * * const ptr, char * const str)$/;"	f
unserial_uint16	serial.cpp	/^uint16_t unserial_uint16(uint8_t * * const ptr)$/;"	f
unserial_uint32	serial.cpp	/^uint32_t unserial_uint32(uint8_t * * const ptr)$/;"	f
unserial_uint64	serial.cpp	/^uint64_t unserial_uint64(uint8_t * * const ptr)$/;"	f
__SERIAL_H_	serial.h	35;"	d
ser_begin	serial.h	42;"	d
ser_btime	serial.h	81;"	d
ser_bytes	serial.h	87;"	d
ser_check	serial.h	56;"	d
ser_declare	serial.h	38;"	d
ser_end	serial.h	51;"	d
ser_float64	serial.h	84;"	d
ser_int16	serial.h	66;"	d
ser_int32	serial.h	71;"	d
ser_int64	serial.h	76;"	d
ser_int8	serial.h	61;"	d
ser_length	serial.h	47;"	d
ser_string	serial.h	93;"	d
ser_struct	serial.h	90;"	d
ser_uint16	serial.h	68;"	d
ser_uint32	serial.h	73;"	d
ser_uint64	serial.h	78;"	d
ser_uint8	serial.h	63;"	d
unser_begin	serial.h	43;"	d
unser_btime	serial.h	118;"	d
unser_bytes	serial.h	124;"	d
unser_declare	serial.h	39;"	d
unser_end	serial.h	52;"	d
unser_float64	serial.h	121;"	d
unser_int16	serial.h	103;"	d
unser_int32	serial.h	108;"	d
unser_int64	serial.h	113;"	d
unser_int8	serial.h	98;"	d
unser_length	serial.h	48;"	d
unser_string	serial.h	130;"	d
unser_struct	serial.h	127;"	d
unser_uint16	serial.h	105;"	d
unser_uint32	serial.h	110;"	d
unser_uint64	serial.h	115;"	d
unser_uint8	serial.h	100;"	d
chunks	similarity_detection.cpp	/^	GSequence *chunks;$/;"	m	struct:__anon18	file:
container_buffer	similarity_detection.cpp	/^	struct container *container_buffer;$/;"	m	struct:__anon18	typeref:struct:__anon18::container	file:
features_trim	similarity_detection.cpp	/^static void features_trim(struct segment *target,$/;"	f	file:
g_segment_cmp_feature_num	similarity_detection.cpp	/^static gint g_segment_cmp_feature_num(struct segment* a,$/;"	f	file:
index_lookup_similarity_detection	similarity_detection.cpp	/^void index_lookup_similarity_detection(struct segment *s){$/;"	f
top_segment_select	similarity_detection.cpp	/^static void top_segment_select(GHashTable* features) {$/;"	f	file:
sync_queue_find	sync_queue.cpp	/^void* sync_queue_find(SyncQueue* s_queue, int (*hit)(void*, void*), void* data,$/;"	f
sync_queue_free	sync_queue.cpp	/^void sync_queue_free(SyncQueue* s_queue, void (*free_data)(void*)) {$/;"	f
sync_queue_get_top	sync_queue.cpp	/^void* sync_queue_get_top(SyncQueue* s_queue) {$/;"	f
sync_queue_new	sync_queue.cpp	/^SyncQueue* sync_queue_new(int size) {$/;"	f
sync_queue_pop	sync_queue.cpp	/^void* sync_queue_pop(SyncQueue* s_queue) {$/;"	f
sync_queue_push	sync_queue.cpp	/^void sync_queue_push(SyncQueue* s_queue, void* item) {$/;"	f
sync_queue_size	sync_queue.cpp	/^int sync_queue_size(SyncQueue* s_queue) {$/;"	f
sync_queue_term	sync_queue.cpp	/^void sync_queue_term(SyncQueue* s_queue) {$/;"	f
SYNC_QUEUE_H_	sync_queue.h	2;"	d
SyncQueue	sync_queue.h	/^} SyncQueue;$/;"	t	typeref:struct:__anon19
max_size	sync_queue.h	/^	int max_size;\/* the max size of queue *\/$/;"	m	struct:__anon19
max_work	sync_queue.h	/^	pthread_cond_t max_work;$/;"	m	struct:__anon19
min_work	sync_queue.h	/^	pthread_cond_t min_work;$/;"	m	struct:__anon19
mutex	sync_queue.h	/^	pthread_mutex_t mutex;$/;"	m	struct:__anon19
queue	sync_queue.h	/^	Queue *queue;$/;"	m	struct:__anon19
term	sync_queue.h	/^	int term; \/\/ terminated$/;"	m	struct:__anon19
code2hash	trace_phase.cpp	/^void code2hash(unsigned char code[40], unsigned char hash[20]) {$/;"	f
hash2code	trace_phase.cpp	/^void hash2code(unsigned char hash[20], char code[40]) {$/;"	f
make_trace	trace_phase.cpp	/^void make_trace(char* path) {$/;"	f
read_trace_thread	trace_phase.cpp	/^static void* read_trace_thread(void *argv) {$/;"	f	file:
start_read_trace_phase	trace_phase.cpp	/^void start_read_trace_phase() {$/;"	f
stop_read_trace_phase	trace_phase.cpp	/^void stop_read_trace_phase() {$/;"	f
trace_queue	trace_phase.cpp	/^SyncQueue* trace_queue;$/;"	v
trace_t	trace_phase.cpp	/^static pthread_t trace_t;$/;"	v	file:
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.8	//
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
