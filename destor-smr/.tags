!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
BACKUP_H_	.\src\backup.h	9;"	d
BF_H_	.\src\bloom_filter.h	2;"	d
BREAKMARK_VALUE	.\src\rabin_chunking.cpp	7;"	d	file:
CHECK_CHUNK	.\src\destor.h	194;"	d
CHUNK_AE	.\src\destor.h	70;"	d
CHUNK_DUPLICATE	.\src\destor.h	174;"	d
CHUNK_FILE	.\src\destor.h	69;"	d
CHUNK_FILE_END	.\src\destor.h	184;"	d
CHUNK_FILE_START	.\src\destor.h	183;"	d
CHUNK_FIXED	.\src\destor.h	66;"	d
CHUNK_H_	.\src\chunking.h	6;"	d
CHUNK_IN_CACHE	.\src\destor.h	178;"	d
CHUNK_NORMALIZED_RABIN	.\src\destor.h	68;"	d
CHUNK_OUT_OF_ORDER	.\src\destor.h	176;"	d
CHUNK_RABIN	.\src\destor.h	67;"	d
CHUNK_READY	.\src\destor.h	190;"	d
CHUNK_REWRITE_DENIED	.\src\destor.h	180;"	d
CHUNK_SEGMENT_END	.\src\destor.h	186;"	d
CHUNK_SEGMENT_START	.\src\destor.h	185;"	d
CHUNK_SIZE_32BIT	.\src\libhashfile.h	371;"	d
CHUNK_SIZE_64BIT	.\src\libhashfile.h	372;"	d
CHUNK_SPARSE	.\src\destor.h	175;"	d
CHUNK_TTTD	.\src\destor.h	71;"	d
CHUNK_UNIQUE	.\src\destor.h	173;"	d
CHUNK_WAIT	.\src\destor.h	189;"	d
CMA_H_	.\src\cma.h	2;"	d
CONTAINERSTORE_H_	.\src\containerstore.h	9;"	d
CONTAINER_HEAD	.\src\containerstore.h	15;"	d
CONTAINER_META_ENTRY	.\src\containerstore.h	16;"	d
CONTAINER_META_SIZE	.\src\containerstore.h	14;"	d
CONTAINER_SIZE	.\src\containerstore.h	13;"	d
Cache_H_	.\src\lru_cache.h	9;"	d
DEBUG	.\src\destor.h	324;"	d
DEFAULT_BLOCK_SIZE	.\src\destor.h	170;"	d
DEKHash	.\src\bloom_filter.cpp	/^unsigned int DEKHash(unsigned char *str, unsigned int len)$/;"	f
DESTOR_BACKUP	.\src\destor.h	43;"	d
DESTOR_CONFIGLINE_MAX	.\src\destor.h	41;"	d
DESTOR_DEBUG	.\src\destor.h	49;"	d
DESTOR_DEFAULT_VERBOSITY	.\src\destor.h	53;"	d
DESTOR_DELETE	.\src\destor.h	46;"	d
DESTOR_H_	.\src\destor.h	9;"	d
DESTOR_MAKE_TRACE	.\src\destor.h	45;"	d
DESTOR_MAX_LOGMSG_LEN	.\src\destor.h	54;"	d
DESTOR_NOTICE	.\src\destor.h	51;"	d
DESTOR_RESTORE	.\src\destor.h	44;"	d
DESTOR_VERBOSE	.\src\destor.h	50;"	d
DESTOR_WARNING	.\src\destor.h	52;"	d
DJBHash	.\src\bloom_filter.cpp	/^unsigned int DJBHash(unsigned char *str, unsigned int len)$/;"	f
FILE_HEADER_SIZE	.\src\libhashfile.cpp	37;"	d	file:
FILTER_BITMASK	.\src\bloom_filter.h	10;"	d
FILTER_SIZE	.\src\bloom_filter.h	7;"	d
FILTER_SIZE_BYTES	.\src\bloom_filter.h	9;"	d
FINGERPRINT_CACHE_H_	.\src\fingerprint_cache.h	9;"	d
FINGERPRINT_PT	.\src\rabin_chunking.cpp	6;"	d	file:
FIXED	.\src\libhashfile.h	/^	FIXED = 1,$/;"	e	enum:chnking_method
FNVHash	.\src\bloom_filter.cpp	/^unsigned int FNVHash(unsigned char *str, unsigned int len)$/;"	f
HASH_FILE_MAGIC	.\src\libhashfile.h	142;"	d
HASH_FILE_VERSION1	.\src\libhashfile.h	150;"	d
HASH_FILE_VERSION2	.\src\libhashfile.h	151;"	d
HASH_FILE_VERSION3	.\src\libhashfile.h	152;"	d
HASH_FILE_VERSION4	.\src\libhashfile.h	153;"	d
HASH_FILE_VERSION5	.\src\libhashfile.h	154;"	d
HASH_FILE_VERSION6	.\src\libhashfile.h	155;"	d
HASH_FILE_VERSION7	.\src\libhashfile.h	156;"	d
INDEX_BUFFER_H_	.\src\index_buffer.h	2;"	d
INDEX_CATEGORY_EXACT	.\src\destor.h	80;"	d
INDEX_CATEGORY_LOGICAL	.\src\destor.h	95;"	d
INDEX_CATEGORY_LOGICAL_LOCALITY	.\src\destor.h	102;"	d
INDEX_CATEGORY_NEAR_EXACT	.\src\destor.h	87;"	d
INDEX_CATEGORY_PHYSICAL_LOCALITY	.\src\destor.h	94;"	d
INDEX_CATEGORY_SIMILARITY	.\src\destor.h	103;"	d
INDEX_H_	.\src\index.h	10;"	d
INDEX_KEY_VALUE_HTABLE	.\src\destor.h	109;"	d
INDEX_KEY_VALUE_MYSQL	.\src\destor.h	110;"	d
INDEX_SAMPLING_MIN	.\src\destor.h	122;"	d
INDEX_SAMPLING_OPTIMIZED_MIN	.\src\destor.h	124;"	d
INDEX_SAMPLING_RANDOM	.\src\destor.h	121;"	d
INDEX_SAMPLING_UNIFORM	.\src\destor.h	123;"	d
INDEX_SEGMENT_CONTENT_DEFINED	.\src\destor.h	132;"	d
INDEX_SEGMENT_FILE_DEFINED	.\src\destor.h	133;"	d
INDEX_SEGMENT_FIXED	.\src\destor.h	131;"	d
INDEX_SEGMENT_SELECT_BASE	.\src\destor.h	140;"	d
INDEX_SEGMENT_SELECT_MIX	.\src\destor.h	142;"	d
INDEX_SEGMENT_SELECT_TOP	.\src\destor.h	141;"	d
INDEX_SPECIFIC_BLOCK_LOCALITY_CACHING	.\src\destor.h	154;"	d
INDEX_SPECIFIC_DDFS	.\src\destor.h	149;"	d
INDEX_SPECIFIC_EXTREME_BINNING	.\src\destor.h	150;"	d
INDEX_SPECIFIC_NO	.\src\destor.h	148;"	d
INDEX_SPECIFIC_SAMPLED	.\src\destor.h	153;"	d
INDEX_SPECIFIC_SILO	.\src\destor.h	151;"	d
INDEX_SPECIFIC_SPARSE	.\src\destor.h	152;"	d
INFI_CACHE	.\src\lru_cache.h	10;"	d
JCR_STATUS_DONE	.\src\jcr.h	17;"	d
JCR_STATUS_INIT	.\src\jcr.h	15;"	d
JCR_STATUS_RUNNING	.\src\jcr.h	16;"	d
JSHash	.\src\bloom_filter.cpp	/^unsigned int JSHash(unsigned char *str, unsigned int len)$/;"	f
Jcr_H_	.\src\jcr.h	9;"	d
KVSTORE_H_	.\src\kvstore.h	2;"	d
MAXBUF	.\src\rabin_chunking.cpp	4;"	d	file:
MAXLINE	.\src\read_fsl_trace.cpp	38;"	d	file:
MAX_CONTAINER_COUNT	.\src\rewrite_phase.h	53;"	d
MAX_PATH_SIZE	.\src\libhashfile.h	143;"	d
MAX_SYSID_LEN	.\src\libhashfile.h	144;"	d
MD5_48BIT_HASH	.\src\libhashfile.h	/^	MD5_48BIT_HASH = 3,$/;"	e	enum:hshing_method
MD5_64BIT_HASH	.\src\libhashfile.h	/^	MD5_64BIT_HASH = 5,$/;"	e	enum:hshing_method
MD5_HASH	.\src\libhashfile.h	/^	MD5_HASH = 1,$/;"	e	enum:hshing_method
MSB64	.\src\rabin_chunking.cpp	3;"	d	file:
MURMUR_HASH	.\src\libhashfile.h	/^	MURMUR_HASH = 4,$/;"	e	enum:hshing_method
NONE	.\src\libhashfile.h	/^	NONE = 0,$/;"	e	enum:cmpr_method
NOTICE	.\src\destor.h	326;"	d
NUM_HASHES	.\src\bloom_filter.h	8;"	d
Node	.\src\cap_rewrite.cpp	/^}Node[MAX_CONTAINER_COUNT];$/;"	v	typeref:struct:containerchunkcount
Node	.\src\ned_rewrite.cpp	/^}Node[MAX_CONTAINER_COUNT];$/;"	v	typeref:struct:containerchunkcount
PJWHash	.\src\bloom_filter.cpp	/^unsigned int PJWHash(unsigned char *str, unsigned int len)$/;"	f
QUEUE_H_	.\src\queue.h	9;"	d
Queue	.\src\queue.h	/^} Queue;$/;"	t	typeref:struct:queue_tag
RABIN	.\src\libhashfile.h	/^	RABIN = 3$/;"	e	enum:var_chnking_algo
RANDOM	.\src\libhashfile.h	/^	RANDOM = 1,$/;"	e	enum:var_chnking_algo
READ	.\src\libhashfile.h	/^	READ = 0,$/;"	e	enum:openmode
RECIPESTORE_H_	.\src\recipestore.h	9;"	d
RESTORE_CACHE_ASM	.\src\destor.h	158;"	d
RESTORE_CACHE_LRU	.\src\destor.h	156;"	d
RESTORE_CACHE_OPT	.\src\destor.h	157;"	d
RESTORE_H_	.\src\restore.h	9;"	d
REWRITE_CAPPING	.\src\destor.h	163;"	d
REWRITE_CFL_SELECTIVE_DEDUPLICATION	.\src\destor.h	161;"	d
REWRITE_CONTEXT_BASED	.\src\destor.h	162;"	d
REWRITE_NED	.\src\destor.h	165;"	d
REWRITE_NO	.\src\destor.h	160;"	d
REWRITE_PHASE_H_	.\src\rewrite_phase.h	9;"	d
REWRITE_SMR	.\src\destor.h	164;"	d
RSHash	.\src\bloom_filter.cpp	/^unsigned int RSHash(unsigned char *str, unsigned int len)$/;"	f
SDBMHash	.\src\bloom_filter.cpp	/^unsigned int SDBMHash(unsigned char *str, unsigned int len)$/;"	f
SDS_MAX_PREALLOC	.\src\sds.h	34;"	d
SET_CHUNK	.\src\destor.h	192;"	d
SHA1_HASH	.\src\libhashfile.h	/^	SHA1_HASH = 6,$/;"	e	enum:hshing_method
SHA256_HASH	.\src\libhashfile.h	/^	SHA256_HASH = 2,$/;"	e	enum:hshing_method
SIMPLE_MATCH	.\src\libhashfile.h	/^	SIMPLE_MATCH = 2,$/;"	e	enum:var_chnking_algo
SIMULATION_ALL	.\src\destor.h	60;"	d
SIMULATION_APPEND	.\src\destor.h	59;"	d
SIMULATION_NO	.\src\destor.h	57;"	d
SIMULATION_RESTORE	.\src\destor.h	58;"	d
SLIDE	.\src\rabin_chunking.cpp	9;"	d	file:
SYNC_QUEUE_H_	.\src\sync_queue.h	2;"	d
SyncQueue	.\src\sync_queue.h	/^} SyncQueue;$/;"	t	typeref:struct:__anon12
T	.\src\rabin_chunking.cpp	/^UINT64 T[256];$/;"	v
TEMPORARY_ID	.\src\destor.h	167;"	d
TIMER_BEGIN	.\src\destor.h	37;"	d
TIMER_DECLARE	.\src\destor.h	36;"	d
TIMER_END	.\src\destor.h	38;"	d
TRACE_DESTOR	.\src\destor.h	63;"	d
TRACE_FSL	.\src\destor.h	64;"	d
U	.\src\rabin_chunking.cpp	/^UINT64 U[256];$/;"	v
UINT32	.\src\rabin_chunking.cpp	/^typedef unsigned int UINT32;$/;"	t	file:
UINT64	.\src\rabin_chunking.cpp	/^typedef unsigned long long int UINT64;$/;"	t	file:
UNSET_CHUNK	.\src\destor.h	193;"	d
VARIABLE	.\src\libhashfile.h	/^	VARIABLE = 2$/;"	e	enum:chnking_method
VERBOSE	.\src\destor.h	325;"	d
WARNING	.\src\destor.h	327;"	d
WRITE	.\src\libhashfile.h	/^	WRITE = 1,$/;"	e	enum:openmode
ZLIB_DEF	.\src\libhashfile.h	/^	ZLIB_DEF = 1$/;"	e	enum:cmpr_method
_FILE_OFFSET_BITS	.\src\libhashfile.cpp	16;"	d	file:
_HASHFILELIB_H	.\src\libhashfile.h	17;"	d
__SDS_H	.\src\sds.h	32;"	d
__SERIAL_H_	.\src\serial.h	35;"	d
_cur_pos	.\src\rabin_chunking.cpp	/^size_t _cur_pos;$/;"	v
_last_pos	.\src\rabin_chunking.cpp	/^size_t _last_pos;$/;"	v
_num_chunks	.\src\rabin_chunking.cpp	/^unsigned int _num_chunks;$/;"	v
abstract_file_header	.\src\libhashfile.h	/^struct abstract_file_header {$/;"	s
accessRecords	.\src\optimal_restore.cpp	/^struct accessRecords {$/;"	s	file:
access_record	.\src\recipestore.cpp	/^static containerid access_record = TEMPORARY_ID;$/;"	v	file:
access_record_table	.\src\optimal_restore.cpp	/^	GHashTable *access_record_table;$/;"	m	struct:__anon9	file:
add_chunk_to_container	.\src\containerstore.cpp	/^int add_chunk_to_container(struct container* c, struct chunk* ck) {$/;"	f
ae_chunk_data	.\src\ae_chunking.cpp	/^int ae_chunk_data(unsigned char *p, int n) {$/;"	f
ae_init	.\src\ae_chunking.cpp	/^void ae_init(){$/;"	f
algo	.\src\libhashfile.h	/^	enum var_chnking_algo algo;$/;"	m	struct:var_chnking_params	typeref:enum:var_chnking_params::var_chnking_algo
algo_params	.\src\libhashfile.h	/^	} algo_params;$/;"	m	struct:var_chnking_params	typeref:union:var_chnking_params::__anon5
all_fp	.\src\cap_rewrite.cpp	/^vector <string> all_fp[MAX_CONTAINER_COUNT];$/;"	v
all_fp	.\src\ned_rewrite.cpp	/^vector <string> all_fp[MAX_CONTAINER_COUNT];$/;"	v
all_fp	.\src\smr_rewrite.cpp	/^vector <string> all_fp[MAX_CONTAINER_COUNT];$/;"	v
append8	.\src\rabin_chunking.cpp	/^UINT64 append8(UINT64 p, unsigned char m) {$/;"	f
append_file_recipe_meta	.\src\recipestore.cpp	/^void append_file_recipe_meta(struct backupVersion* b, struct fileRecipeMeta* r) {$/;"	f
append_n_chunk_pointers	.\src\recipestore.cpp	/^void append_n_chunk_pointers(struct backupVersion* b,$/;"	f
append_segment_flag	.\src\recipestore.cpp	/^segmentid append_segment_flag(struct backupVersion* b, int flag, int segment_size){$/;"	f
append_t	.\src\containerstore.cpp	/^static pthread_t append_t;$/;"	v	file:
append_thread	.\src\containerstore.cpp	/^static void* append_thread(void *arg) {$/;"	f	file:
area	.\src\assembly_restore.cpp	/^	GSequence *area;$/;"	m	struct:__anon1	file:
area_size	.\src\assembly_restore.cpp	/^	int64_t area_size;$/;"	m	struct:__anon1	file:
assemble_area	.\src\assembly_restore.cpp	/^static GQueue* assemble_area() {$/;"	f	file:
assembly_area	.\src\assembly_restore.cpp	/^} assembly_area;$/;"	v	typeref:struct:__anon1
assembly_area_push	.\src\assembly_restore.cpp	/^static int assembly_area_push(struct chunk* c) {$/;"	f	file:
assembly_restore_thread	.\src\assembly_restore.cpp	/^void* assembly_restore_thread(void *arg) {$/;"	f
atime	.\src\libhashfile.h	/^	uint64_t atime;			\/* file atime *\/$/;"	m	struct:file_header_v3
atime	.\src\libhashfile.h	/^	uint64_t atime;			\/* file atime *\/$/;"	m	struct:file_header_v4
atime	.\src\libhashfile.h	/^	uint64_t atime;$/;"	m	struct:abstract_file_header
backupVersion	.\src\recipestore.h	/^struct backupVersion {$/;"	s
backup_retention_time	.\src\destor.h	/^	int backup_retention_time;$/;"	m	struct:structdestor
backup_version_count	.\src\recipestore.cpp	/^static int32_t backup_version_count;$/;"	v	file:
backup_version_exists	.\src\recipestore.cpp	/^int backup_version_exists(int number) {$/;"	f
bits_to_compare	.\src\libhashfile.h	/^	uint32_t bits_to_compare;$/;"	m	struct:var_rabin_chnk_params
bits_to_compare	.\src\libhashfile.h	/^	uint32_t bits_to_compare;$/;"	m	struct:var_simple_chnk_params
blocks	.\src\libhashfile.h	/^	uint64_t blocks;		\/* 512B blocks allocated by fs *\/$/;"	m	struct:file_header_v4
blocks	.\src\libhashfile.h	/^	uint64_t blocks;$/;"	m	struct:abstract_file_header
buckets	.\src\cbr_rewrite.cpp	/^	int32_t buckets[10000];$/;"	m	struct:__anon2	file:
buf	.\src\rabin_chunking.cpp	/^unsigned char buf[size];$/;"	v
buf	.\src\sds.h	/^    char buf[];$/;"	m	struct:sdshdr
buffered_access_record_num	.\src\optimal_restore.cpp	/^	int buffered_access_record_num;$/;"	m	struct:__anon9	file:
buffered_fingerprints	.\src\index_buffer.h	/^    GHashTable *buffered_fingerprints;$/;"	m	struct:index_buffer
bufpos	.\src\rabin_chunking.cpp	/^int bufpos;$/;"	v
bv	.\src\jcr.h	/^	struct backupVersion* bv;$/;"	m	struct:structjcr	typeref:struct:structjcr::backupVersion
bv_num	.\src\recipestore.h	/^	int32_t bv_num; \/* backup version number start from 0 *\/$/;"	m	struct:backupVersion
bytemsb	.\src\rabin_chunking.cpp	/^const char bytemsb[0x100] = { 0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5,$/;"	v
bytes	.\src\libhashfile.h	/^	uint64_t bytes;$/;"	m	struct:header_v4
cache	.\src\restore_aware.cpp	/^	struct lruCache *cache;$/;"	m	struct:__anon11	typeref:struct:__anon11::lruCache	file:
calcT	.\src\rabin_chunking.cpp	/^void calcT(UINT64 poly) {$/;"	f
cap_rewrite	.\src\cap_rewrite.cpp	/^void *cap_rewrite(void* arg) {$/;"	f
cbr_rewrite	.\src\cbr_rewrite.cpp	/^void *cbr_rewrite(void* arg) {$/;"	f
ccf	.\src\restore_aware.cpp	/^	int ccf;$/;"	m	struct:__anon11	file:
cfl	.\src\restore_aware.cpp	/^	double cfl; \/\/ocf\/ccf$/;"	m	struct:__anon11	file:
cfl_rewrite	.\src\cfl_rewrite.cpp	/^void *cfl_rewrite(void* arg) {$/;"	f
check_simulation_level	.\src\destor.cpp	/^void check_simulation_level(int last_level, int current_level) {$/;"	f
chnk_method	.\src\libhashfile.h	/^	enum chnking_method chnk_method;$/;"	m	struct:header	typeref:enum:header::chnking_method
chnk_method	.\src\libhashfile.h	/^	enum chnking_method chnk_method;$/;"	m	struct:header_v3	typeref:enum:header_v3::chnking_method
chnk_method	.\src\libhashfile.h	/^	enum chnking_method chnk_method;$/;"	m	struct:header_v4	typeref:enum:header_v4::chnking_method
chnk_method_params	.\src\libhashfile.h	/^	} chnk_method_params;$/;"	m	struct:header	typeref:union:header::__anon6
chnk_method_params	.\src\libhashfile.h	/^	} chnk_method_params;$/;"	m	struct:header_v3	typeref:union:header_v3::__anon7
chnk_method_params	.\src\libhashfile.h	/^	} chnk_method_params;$/;"	m	struct:header_v4	typeref:union:header_v4::__anon8
chnking_method	.\src\libhashfile.h	/^enum chnking_method$/;"	g
chunk	.\src\destor.h	/^struct chunk {$/;"	s
chunkAlg_init	.\src\rabin_chunking.cpp	/^void chunkAlg_init() {$/;"	f
chunkPointer	.\src\recipestore.h	/^struct chunkPointer {$/;"	s
chunk_algorithm	.\src\destor.h	/^	int chunk_algorithm;$/;"	m	struct:structdestor
chunk_avg_size	.\src\destor.h	/^	int chunk_avg_size;$/;"	m	struct:structdestor
chunk_info	.\src\libhashfile.h	/^struct chunk_info {$/;"	s
chunk_max_size	.\src\destor.h	/^	int chunk_max_size;$/;"	m	struct:structdestor
chunk_min_size	.\src\destor.h	/^	int chunk_min_size;$/;"	m	struct:structdestor
chunk_num	.\src\cap_rewrite.cpp	/^static int64_t chunk_num;$/;"	v	file:
chunk_num	.\src\cbr_rewrite.cpp	/^	int32_t chunk_num;$/;"	m	struct:__anon2	file:
chunk_num	.\src\cbr_rewrite.cpp	/^static int64_t chunk_num;$/;"	v	file:
chunk_num	.\src\cfl_rewrite.cpp	/^static int64_t chunk_num;$/;"	v	file:
chunk_num	.\src\chunk_phase.cpp	/^static int64_t chunk_num;$/;"	v	file:
chunk_num	.\src\containerstore.h	/^	int32_t chunk_num;$/;"	m	struct:containerMeta
chunk_num	.\src\dedup_phase.cpp	/^static int64_t chunk_num;$/;"	v	file:
chunk_num	.\src\destor.h	/^	int32_t chunk_num;$/;"	m	struct:segment
chunk_num	.\src\destor.h	/^	int64_t chunk_num;$/;"	m	struct:structdestor
chunk_num	.\src\filter_phase.cpp	/^static int64_t chunk_num;$/;"	v	file:
chunk_num	.\src\hash_phase.cpp	/^static int64_t chunk_num;$/;"	v	file:
chunk_num	.\src\index_buffer.h	/^    int chunk_num;$/;"	m	struct:index_buffer
chunk_num	.\src\jcr.h	/^	int32_t chunk_num;$/;"	m	struct:structjcr
chunk_num	.\src\ned_rewrite.cpp	/^static int64_t chunk_num;$/;"	v	file:
chunk_num	.\src\smr_rewrite.cpp	/^static int64_t chunk_num;$/;"	v	file:
chunk_queue	.\src\chunk_phase.cpp	/^SyncQueue* chunk_queue;$/;"	v
chunk_queue	.\src\rewrite_phase.h	/^	GQueue *chunk_queue;$/;"	m	struct:structrewritebuffer
chunk_size	.\src\libhashfile.h	/^	uint32_t chunk_size;$/;"	m	struct:fixed_chnking_params
chunk_t	.\src\chunk_phase.cpp	/^static pthread_t chunk_t;$/;"	v	file:
chunk_thread	.\src\chunk_phase.cpp	/^static void* chunk_thread(void *arg) {$/;"	f	file:
chunk_time	.\src\jcr.h	/^	double chunk_time;$/;"	m	struct:structjcr
chunkcount	.\src\cap_rewrite.cpp	/^	int64_t chunkcount;$/;"	m	struct:containerchunkcount	file:
chunkcount	.\src\ned_rewrite.cpp	/^	int64_t chunkcount;$/;"	m	struct:containerchunkcount	file:
chunking	.\src\chunk_phase.cpp	/^static int (*chunking)(unsigned char* buf, int size);$/;"	v	file:
chunknum	.\src\recipestore.h	/^	int64_t chunknum;$/;"	m	struct:fileRecipeMeta
chunks	.\src\destor.h	/^	GSequence *chunks;$/;"	m	struct:segment
chunks	.\src\filter_phase.cpp	/^	GSequence *chunks;$/;"	m	struct:structstoragebuffer	file:
chunks	.\src\index.cpp	/^    GSequence *chunks;$/;"	m	struct:structstoragebuffer	file:
chunks	.\src\libhashfile.h	/^	uint64_t chunks;		\/* chunks\/indexes in this file *\/$/;"	m	struct:file_header
chunks	.\src\libhashfile.h	/^	uint64_t chunks;		\/* chunks\/indexes in this file *\/$/;"	m	struct:file_header_v2
chunks	.\src\libhashfile.h	/^	uint64_t chunks;		\/* chunks\/indexes in this file *\/$/;"	m	struct:file_header_v3
chunks	.\src\libhashfile.h	/^	uint64_t chunks;		\/* chunks\/indexes in this file *\/$/;"	m	struct:file_header_v4
chunks	.\src\libhashfile.h	/^	uint64_t chunks; 		\/* number of chunks\/indexes *\/$/;"	m	struct:header
chunks	.\src\libhashfile.h	/^	uint64_t chunks; 		\/* number of chunks\/indexes *\/$/;"	m	struct:header_v3
chunks	.\src\libhashfile.h	/^	uint64_t chunks; 		\/* number of chunks\/indexes *\/$/;"	m	struct:header_v4
chunks	.\src\libhashfile.h	/^	uint64_t chunks;$/;"	m	struct:abstract_file_header
chunks	.\src\similarity_detection.cpp	/^	GSequence *chunks;$/;"	m	struct:structstoragebuffer	file:
cid	.\src\optimal_restore.cpp	/^	containerid cid;$/;"	m	struct:accessRecords	file:
cid	.\src\rewrite_phase.h	/^	containerid cid;$/;"	m	struct:containerRecord
close_container_store	.\src\containerstore.cpp	/^void close_container_store() {$/;"	f
close_har	.\src\har_rewrite.cpp	/^void close_har() {$/;"	f
close_index	.\src\index.cpp	/^void close_index() {$/;"	f
close_kvstore	.\src\kvstore.cpp	/^void (*close_kvstore)();$/;"	v
close_kvstore_htable	.\src\kvstore_htable.cpp	/^void close_kvstore_htable() {$/;"	f
close_recipe_store	.\src\recipestore.cpp	/^void close_recipe_store() {$/;"	f
cmpr_method	.\src\libhashfile.h	/^enum cmpr_method$/;"	g
code2hash	.\src\destor.cpp	/^void code2hash(unsigned char code[40], unsigned char hash[20]) {$/;"	f
cond	.\src\cap_rewrite.cpp	/^	pthread_cond_t cond; \/\/ index buffer is not full$/;"	m	struct:structindexlock	file:
cond	.\src\dedup_phase.cpp	/^	pthread_cond_t cond; \/\/ index buffer is not full$/;"	m	struct:structindexlock	file:
cond	.\src\filter_phase.cpp	/^    pthread_cond_t cond; \/\/ index buffer is not full$/;"	m	struct:structindexlock	file:
cond	.\src\index.cpp	/^    pthread_cond_t cond; \/\/ index buffer is not full$/;"	m	struct:structindexlock	file:
cond	.\src\ned_rewrite.cpp	/^	pthread_cond_t cond; \/\/ index buffer is not full$/;"	m	struct:structindexlock	file:
cond	.\src\smr_rewrite.cpp	/^	pthread_cond_t cond; \/\/ index buffer is not full$/;"	m	struct:structindexlock	file:
container	.\src\containerstore.h	/^struct container {$/;"	s
containerMeta	.\src\containerstore.h	/^struct containerMeta {$/;"	s
containerRecord	.\src\rewrite_phase.h	/^struct containerRecord {$/;"	s
container_buffer	.\src\containerstore.cpp	/^static SyncQueue* container_buffer;$/;"	v	file:
container_buffer	.\src\filter_phase.cpp	/^	struct container *container_buffer;$/;"	m	struct:structstoragebuffer	typeref:struct:structstoragebuffer::container	file:
container_buffer	.\src\index.cpp	/^    struct container *container_buffer;$/;"	m	struct:structstoragebuffer	typeref:struct:structstoragebuffer::container	file:
container_buffer	.\src\similarity_detection.cpp	/^	struct container *container_buffer;$/;"	m	struct:structstoragebuffer	typeref:struct:structstoragebuffer::container	file:
container_check_id	.\src\containerstore.cpp	/^int container_check_id(void *c1, void *id1) {$/;"	f
container_count	.\src\containerstore.cpp	/^static int64_t container_count = 0;$/;"	v	file:
container_empty	.\src\containerstore.cpp	/^int container_empty(struct container* c) {$/;"	f
container_meta_check_id	.\src\containerstore.cpp	/^int container_meta_check_id(void *cm1, void *id1) {$/;"	f
container_meta_duplicate	.\src\containerstore.cpp	/^static void * container_meta_duplicate(void *c1) {$/;"	f	file:
container_meta_foreach	.\src\containerstore.cpp	/^void container_meta_foreach(struct containerMeta* cm, void (*func)(fingerprint*, void*), void* data){$/;"	f
container_overflow	.\src\containerstore.cpp	/^int container_overflow(struct container* c, int32_t size) {$/;"	f
container_record_check_id	.\src\restore_aware.cpp	/^static int container_record_check_id(void *a1, void *id1) {$/;"	f	file:
container_record_seq	.\src\rewrite_phase.h	/^	GSequence *container_record_seq; \/\/$/;"	m	struct:structrewritebuffer
container_selected	.\src\smr_rewrite.cpp	/^vector <int> container_selected;$/;"	v
container_utilization_monitor	.\src\har_rewrite.cpp	/^static GHashTable *container_utilization_monitor;$/;"	v	file:
containerchunkcount	.\src\cap_rewrite.cpp	/^	containerchunkcount() {$/;"	f	struct:containerchunkcount
containerchunkcount	.\src\cap_rewrite.cpp	/^struct containerchunkcount{$/;"	s	file:
containerchunkcount	.\src\ned_rewrite.cpp	/^	containerchunkcount() {$/;"	f	struct:containerchunkcount
containerchunkcount	.\src\ned_rewrite.cpp	/^struct containerchunkcount{$/;"	s	file:
containerid	.\src\destor.h	/^typedef int64_t containerid; \/\/container id$/;"	t
convert_to_abstract_file_header	.\src\libhashfile.cpp	/^static void convert_to_abstract_file_header(int version, uint8_t *fhdr,$/;"	f	file:
cratio	.\src\libhashfile.h	/^	uint8_t cratio;$/;"	m	struct:chunk_info
create_backup_version	.\src\recipestore.cpp	/^struct backupVersion* create_backup_version(const char *path) {$/;"	f
create_container	.\src\containerstore.cpp	/^struct container* create_container() {$/;"	f
ctime	.\src\libhashfile.h	/^	uint64_t ctime;			\/* file ctime *\/$/;"	m	struct:file_header_v3
ctime	.\src\libhashfile.h	/^	uint64_t ctime;			\/* file ctime *\/$/;"	m	struct:file_header_v4
ctime	.\src\libhashfile.h	/^	uint64_t ctime;$/;"	m	struct:abstract_file_header
current_chunk_info	.\src\libhashfile.h	/^	struct chunk_info		current_chunk_info;$/;"	m	struct:hashfile_handle	typeref:struct:hashfile_handle::chunk_info
current_file	.\src\libhashfile.h	/^	struct abstract_file_header 	current_file;$/;"	m	struct:hashfile_handle	typeref:struct:hashfile_handle::abstract_file_header
current_file_header_offset	.\src\libhashfile.h	/^	off_t				current_file_header_offset;$/;"	m	struct:hashfile_handle
current_sequence_number	.\src\optimal_restore.cpp	/^	int current_sequence_number;$/;"	m	struct:__anon9	file:
current_utility_threshold	.\src\cbr_rewrite.cpp	/^	double current_utility_threshold;$/;"	m	struct:__anon2	file:
data	.\src\containerstore.h	/^	unsigned char *data;$/;"	m	struct:container
data	.\src\destor.h	/^	unsigned char *data;$/;"	m	struct:chunk
data	.\src\queue.h	/^	void *data;$/;"	m	struct:queue_ele_tag
data_size	.\src\containerstore.h	/^	int32_t data_size;$/;"	m	struct:containerMeta
data_size	.\src\destor.h	/^	int64_t data_size;$/;"	m	struct:structdestor
data_size	.\src\jcr.h	/^	int64_t data_size;$/;"	m	struct:structjcr
dedup_queue	.\src\dedup_phase.cpp	/^SyncQueue* dedup_queue;$/;"	v
dedup_t	.\src\dedup_phase.cpp	/^static pthread_t dedup_t;$/;"	v	file:
dedup_thread	.\src\dedup_phase.cpp	/^void *dedup_thread(void *arg) {$/;"	f
dedup_time	.\src\jcr.h	/^	double dedup_time;$/;"	m	struct:structjcr
delete_an_entry	.\src\do_delete.cpp	/^static inline void delete_an_entry(fingerprint *fp, void *id1){$/;"	f	file:
deleted	.\src\recipestore.h	/^	int deleted;$/;"	m	struct:backupVersion
destor	.\src\destor.cpp	/^struct structdestor destor;$/;"	v	typeref:struct:structdestor
destor_log	.\src\destor.cpp	/^void destor_log(int level, const char *fmt, ...) {$/;"	f
destor_shutdown	.\src\destor.cpp	/^void destor_shutdown() {$/;"	f
destor_start	.\src\destor.cpp	/^void destor_start() {$/;"	f
destor_stat	.\src\destor.cpp	/^void destor_stat() {$/;"	f
deviceid	.\src\libhashfile.h	/^	uint64_t deviceid;		\/* file device id *\/$/;"	m	struct:file_header_v3
deviceid	.\src\libhashfile.h	/^	uint64_t deviceid;		\/* file device id *\/$/;"	m	struct:file_header_v4
deviceid	.\src\libhashfile.h	/^	uint64_t deviceid;$/;"	m	struct:abstract_file_header
do_add_file	.\src\libhashfile.cpp	/^static int do_add_file(struct hashfile_handle *handle, const char *file_path,$/;"	f	file:
do_backup	.\src\do_backup.cpp	/^void do_backup(char *path) {$/;"	f
do_delete	.\src\do_delete.cpp	/^void do_delete(int jobid) {$/;"	f
do_restore	.\src\do_restore.cpp	/^void do_restore(int revision, char *path) {$/;"	f
eFiles	.\src\rabin_chunking.cpp	/^char *eFiles[] = { ".pdf", ".rmv", "ra", ".bmp", ".vmem", ".vmdk", ".jpeg",$/;"	v
elem_num	.\src\queue.h	/^	int elem_num;$/;"	m	struct:queue_tag
elem_queue	.\src\lru_cache.h	/^	GList *elem_queue;$/;"	m	struct:lruCache
end_time	.\src\libhashfile.h	/^	uint64_t end_time;$/;"	m	struct:header_v3
end_time	.\src\libhashfile.h	/^	uint64_t end_time;$/;"	m	struct:header_v4
fd	.\src\libhashfile.h	/^	int 				fd;$/;"	m	struct:hashfile_handle
features	.\src\destor.h	/^	GHashTable* features;$/;"	m	struct:segment
features_trim	.\src\similarity_detection.cpp	/^static void features_trim(struct segment *target,$/;"	f	file:
fileRecipeMeta	.\src\recipestore.h	/^struct fileRecipeMeta {$/;"	s
file_header	.\src\libhashfile.h	/^struct file_header {$/;"	s
file_header_v2	.\src\libhashfile.h	/^struct file_header_v2 {$/;"	s
file_header_v3	.\src\libhashfile.h	/^struct file_header_v3 {$/;"	s
file_header_v4	.\src\libhashfile.h	/^struct file_header_v4 {$/;"	s
file_num	.\src\jcr.h	/^	int32_t file_num;$/;"	m	struct:structjcr
file_size	.\src\libhashfile.h	/^	uint64_t file_size;		\/* in bytes *\/$/;"	m	struct:file_header
file_size	.\src\libhashfile.h	/^	uint64_t file_size;		\/* in bytes *\/$/;"	m	struct:file_header_v2
file_size	.\src\libhashfile.h	/^	uint64_t file_size;		\/* in bytes *\/$/;"	m	struct:file_header_v3
file_size	.\src\libhashfile.h	/^	uint64_t file_size;		\/* in bytes *\/$/;"	m	struct:file_header_v4
file_size	.\src\libhashfile.h	/^	uint64_t file_size;$/;"	m	struct:abstract_file_header
filename	.\src\recipestore.h	/^	sds filename;$/;"	m	struct:fileRecipeMeta
files	.\src\libhashfile.h	/^	uint64_t files;$/;"	m	struct:header
files	.\src\libhashfile.h	/^	uint64_t files;$/;"	m	struct:header_v3
files	.\src\libhashfile.h	/^	uint64_t files;$/;"	m	struct:header_v4
filesize	.\src\recipestore.h	/^	int64_t filesize;$/;"	m	struct:fileRecipeMeta
filter_t	.\src\filter_phase.cpp	/^static pthread_t filter_t;$/;"	v	file:
filter_thread	.\src\filter_phase.cpp	/^static void* filter_thread(void *arg) {$/;"	f	file:
filter_time	.\src\jcr.h	/^	double filter_time;$/;"	m	struct:structjcr
find_kicked_container	.\src\optimal_restore.cpp	/^static int find_kicked_container(void *con1, void *ht1) {$/;"	f	file:
find_kicked_container_meta	.\src\optimal_restore.cpp	/^static int find_kicked_container_meta(void *cm1, void *ht1) {$/;"	f	file:
find_one_file	.\src\read_phase.cpp	/^static void find_one_file(sds path) {$/;"	f	file:
fingerprint	.\src\destor.h	/^typedef unsigned char fingerprint[20];$/;"	t
fingerprint_cache_lookup	.\src\fingerprint_cache.cpp	/^int64_t fingerprint_cache_lookup(fingerprint *fp){$/;"	f
fingerprint_cache_prefetch	.\src\fingerprint_cache.cpp	/^void fingerprint_cache_prefetch(int64_t id){$/;"	f
first	.\src\queue.h	/^	queue_ele_t *first, *last; \/* work queue *\/$/;"	m	struct:queue_tag
fixed_chnking_params	.\src\libhashfile.h	/^struct fixed_chnking_params$/;"	s
fixed_chunk_data	.\src\chunk_phase.cpp	/^static inline int fixed_chunk_data(unsigned char* buf, int size){$/;"	f	file:
fixed_params	.\src\libhashfile.h	/^		struct fixed_chnking_params fixed_params;$/;"	m	union:header::__anon6	typeref:struct:header::__anon6::fixed_chnking_params
fixed_params	.\src\libhashfile.h	/^		struct fixed_chnking_params fixed_params;$/;"	m	union:header_v3::__anon7	typeref:struct:header_v3::__anon7::fixed_chnking_params
fixed_params	.\src\libhashfile.h	/^		struct fixed_chnking_params fixed_params;$/;"	m	union:header_v4::__anon8	typeref:struct:header_v4::__anon8::fixed_chnking_params
flag	.\src\destor.h	/^	int flag;$/;"	m	struct:chunk
fls32	.\src\rabin_chunking.cpp	/^static uint32_t fls32(UINT32 v) {$/;"	f	file:
fls64	.\src\rabin_chunking.cpp	/^static uint32_t fls64(UINT64 v) {$/;"	f	file:
fname_prefix	.\src\recipestore.h	/^	sds fname_prefix; \/* The prefix of the file names *\/$/;"	m	struct:backupVersion
fp	.\src\containerstore.cpp	/^	fingerprint fp;$/;"	m	struct:metaEntry	file:
fp	.\src\containerstore.cpp	/^static FILE* fp;$/;"	v	file:
fp	.\src\destor.h	/^	fingerprint fp;$/;"	m	struct:chunk
fp	.\src\index_buffer.h	/^    fingerprint fp;$/;"	m	struct:indexElem
fp	.\src\rabin_chunking.cpp	/^UINT64 fp;$/;"	v
fp	.\src\recipestore.h	/^	fingerprint fp;$/;"	m	struct:chunkPointer
free	.\src\sds.h	/^    int free;$/;"	m	struct:sdshdr
free_access_records	.\src\optimal_restore.cpp	/^static void free_access_records(struct accessRecords* r) {$/;"	f	file:
free_backup_version	.\src\recipestore.cpp	/^void free_backup_version(struct backupVersion *b) {$/;"	f
free_chunk	.\src\destor.cpp	/^void free_chunk(struct chunk* ck) {$/;"	f
free_container	.\src\containerstore.cpp	/^void free_container(void * c1) {$/;"	f
free_container_meta	.\src\containerstore.cpp	/^void free_container_meta(void * cm1){$/;"	f
free_elem	.\src\lru_cache.h	/^	void (*free_elem)(void *);$/;"	m	struct:lruCache
free_file_recipe_meta	.\src\recipestore.cpp	/^void free_file_recipe_meta(struct fileRecipeMeta* r) {$/;"	f
free_kvpair	.\src\kvstore_htable.cpp	/^static inline void free_kvpair(kvpair kvp){$/;"	f	file:
free_lru_cache	.\src\lru_cache.cpp	/^void free_lru_cache(struct lruCache* c) {$/;"	f
free_segment	.\src\destor.cpp	/^void free_segment(struct segment* s) {$/;"	f
free_segment_recipe	.\src\recipestore.cpp	/^void free_segment_recipe(void *sr1) {$/;"	f
g_access_records_cmp_by_first_seqno	.\src\optimal_restore.cpp	/^static gint g_access_records_cmp_by_first_seqno(struct accessRecords *a,$/;"	f	file:
g_chunk_cmp	.\src\destor.cpp	/^gint g_chunk_cmp(struct chunk* a, struct chunk* b, gpointer user_data){$/;"	f
g_container_cmp_desc	.\src\containerstore.cpp	/^gint g_container_cmp_desc(struct container* c1, struct container* c2,$/;"	f
g_container_meta_cmp_desc	.\src\containerstore.cpp	/^gint g_container_meta_cmp_desc(struct containerMeta* cm1,$/;"	f
g_feature_equal	.\src\index.cpp	/^gboolean g_feature_equal(char* a, char* b){$/;"	f
g_feature_hash	.\src\index.cpp	/^guint g_feature_hash(char *feature){$/;"	f
g_fingerprint_cmp	.\src\destor.cpp	/^gint g_fingerprint_cmp(fingerprint* fp1, fingerprint* fp2, gpointer user_data) {$/;"	f
g_fingerprint_equal	.\src\destor.cpp	/^gboolean g_fingerprint_equal(fingerprint* fp1, fingerprint* fp2) {$/;"	f
g_record_cmp	.\src\har_rewrite.cpp	/^static gint g_record_cmp(struct containerRecord *a, struct containerRecord* b, gpointer user_data){$/;"	f	file:
g_record_cmp_by_id	.\src\rewrite_phase.cpp	/^gint g_record_cmp_by_id(struct containerRecord* a, struct containerRecord* b,$/;"	f
g_record_descmp_by_length	.\src\rewrite_phase.cpp	/^gint g_record_descmp_by_length(struct containerRecord* a,$/;"	f
g_segment_cmp_feature_num	.\src\similarity_detection.cpp	/^static gint g_segment_cmp_feature_num(struct segment* a,$/;"	f	file:
get_chunk_in_container	.\src\containerstore.cpp	/^struct chunk* get_chunk_in_container(struct container* c, fingerprint *fp) {$/;"	f
get_container_id	.\src\containerstore.cpp	/^containerid get_container_id(struct container* c) {$/;"	f
get_key	.\src\kvstore_htable.cpp	13;"	d	file:
get_metaentry_in_container_meta	.\src\containerstore.cpp	/^static struct metaEntry* get_metaentry_in_container_meta($/;"	f	file:
get_next_version_number	.\src\recipestore.cpp	/^int32_t get_next_version_number() {$/;"	f
get_rewrite_utility	.\src\cbr_rewrite.cpp	/^static double get_rewrite_utility(struct chunk *c) {$/;"	f	file:
get_value	.\src\kvstore_htable.cpp	14;"	d	file:
gid	.\src\libhashfile.h	/^	uint32_t gid;			\/* gid of file owner *\/$/;"	m	struct:file_header_v3
gid	.\src\libhashfile.h	/^	uint32_t gid;			\/* gid of file owner *\/$/;"	m	struct:file_header_v4
gid	.\src\libhashfile.h	/^	uint32_t gid;$/;"	m	struct:abstract_file_header
har_check	.\src\har_rewrite.cpp	/^void har_check(struct chunk* c) {$/;"	f
har_monitor_update	.\src\har_rewrite.cpp	/^void har_monitor_update(containerid id, int32_t size) {$/;"	f
hardlinks	.\src\libhashfile.h	/^	uint64_t hardlinks;		\/* number of hardlinks *\/$/;"	m	struct:file_header_v3
hardlinks	.\src\libhashfile.h	/^	uint64_t hardlinks;		\/* number of hardlinks *\/$/;"	m	struct:file_header_v4
hardlinks	.\src\libhashfile.h	/^	uint64_t hardlinks;$/;"	m	struct:abstract_file_header
hash	.\src\libhashfile.h	/^	uint8_t *hash; \/* this points to static memory! *\/$/;"	m	struct:chunk_info
hash2code	.\src\destor.cpp	/^void hash2code(unsigned char hash[20], char code[40]) {$/;"	f
hash_func	.\src\bloom_filter.cpp	/^unsigned int (*hash_func[])(unsigned char *, unsigned int) = { $/;"	v
hash_queue	.\src\hash_phase.cpp	/^SyncQueue* hash_queue;$/;"	v
hash_size	.\src\libhashfile.h	/^	uint32_t hash_size;		\/* in bits *\/$/;"	m	struct:header
hash_size	.\src\libhashfile.h	/^	uint32_t hash_size;		\/* in bits *\/$/;"	m	struct:header_v3
hash_size	.\src\libhashfile.h	/^	uint32_t hash_size;		\/* in bits *\/$/;"	m	struct:header_v4
hash_t	.\src\hash_phase.cpp	/^static pthread_t hash_t;$/;"	v	file:
hash_time	.\src\jcr.h	/^	double hash_time;$/;"	m	struct:structjcr
hashfile_add_chunk	.\src\libhashfile.cpp	/^int hashfile_add_chunk(struct hashfile_handle *handle,$/;"	f
hashfile_add_file	.\src\libhashfile.cpp	/^int hashfile_add_file(struct hashfile_handle *handle,$/;"	f
hashfile_chunking_method	.\src\libhashfile.cpp	/^enum chnking_method hashfile_chunking_method(struct hashfile_handle *handle)$/;"	f
hashfile_chunking_method_str	.\src\libhashfile.cpp	/^int hashfile_chunking_method_str(struct hashfile_handle *handle,$/;"	f
hashfile_close	.\src\libhashfile.cpp	/^void hashfile_close(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_atime	.\src\libhashfile.cpp	/^uint64_t hashfile_curfile_atime(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_blocks	.\src\libhashfile.cpp	/^uint64_t hashfile_curfile_blocks(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_ctime	.\src\libhashfile.cpp	/^uint64_t hashfile_curfile_ctime(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_deviceid	.\src\libhashfile.cpp	/^uint64_t hashfile_curfile_deviceid(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_gid	.\src\libhashfile.cpp	/^uint32_t hashfile_curfile_gid(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_hardlinks	.\src\libhashfile.cpp	/^uint64_t hashfile_curfile_hardlinks(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_inodenum	.\src\libhashfile.cpp	/^uint64_t hashfile_curfile_inodenum(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_linkpath	.\src\libhashfile.cpp	/^char *hashfile_curfile_linkpath(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_mtime	.\src\libhashfile.cpp	/^uint64_t hashfile_curfile_mtime(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_numchunks	.\src\libhashfile.cpp	/^uint64_t hashfile_curfile_numchunks(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_path	.\src\libhashfile.cpp	/^const char *hashfile_curfile_path(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_perm	.\src\libhashfile.cpp	/^uint64_t hashfile_curfile_perm(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_size	.\src\libhashfile.cpp	/^uint64_t hashfile_curfile_size(struct hashfile_handle *handle)$/;"	f
hashfile_curfile_uid	.\src\libhashfile.cpp	/^uint32_t hashfile_curfile_uid(struct hashfile_handle *handle)$/;"	f
hashfile_end_time	.\src\libhashfile.cpp	/^uint64_t hashfile_end_time(struct hashfile_handle *handle)$/;"	f
hashfile_fxd_chunking_params	.\src\libhashfile.cpp	/^int hashfile_fxd_chunking_params(struct hashfile_handle *handle,$/;"	f
hashfile_handle	.\src\libhashfile.h	/^struct hashfile_handle {$/;"	s
hashfile_hash_size	.\src\libhashfile.cpp	/^uint32_t hashfile_hash_size(struct hashfile_handle *handle)$/;"	f
hashfile_hashing_method	.\src\libhashfile.cpp	/^enum hshing_method hashfile_hashing_method(struct hashfile_handle *handle)$/;"	f
hashfile_hashing_method_str	.\src\libhashfile.cpp	/^int hashfile_hashing_method_str(struct hashfile_handle *handle,$/;"	f
hashfile_next_chunk	.\src\libhashfile.cpp	/^const struct chunk_info *hashfile_next_chunk(struct hashfile_handle *handle)$/;"	f
hashfile_next_file	.\src\libhashfile.cpp	/^int hashfile_next_file(struct hashfile_handle *handle)$/;"	f
hashfile_numbytes	.\src\libhashfile.cpp	/^uint64_t hashfile_numbytes(struct hashfile_handle *handle)$/;"	f
hashfile_numchunks	.\src\libhashfile.cpp	/^uint64_t hashfile_numchunks(struct hashfile_handle *handle)$/;"	f
hashfile_numfiles	.\src\libhashfile.cpp	/^uint64_t hashfile_numfiles(struct hashfile_handle *handle)$/;"	f
hashfile_open	.\src\libhashfile.cpp	/^struct hashfile_handle *hashfile_open(char *hashfile_name)$/;"	f
hashfile_open4write	.\src\libhashfile.cpp	/^struct hashfile_handle *hashfile_open4write(char *hashfile_name, enum$/;"	f
hashfile_reset	.\src\libhashfile.cpp	/^int hashfile_reset(struct hashfile_handle *handle)$/;"	f
hashfile_rootpath	.\src\libhashfile.cpp	/^const char *hashfile_rootpath(struct hashfile_handle *handle)$/;"	f
hashfile_set_fxd_chnking_params	.\src\libhashfile.cpp	/^int hashfile_set_fxd_chnking_params(struct hashfile_handle *handle,$/;"	f
hashfile_set_var_chnking_params	.\src\libhashfile.cpp	/^int hashfile_set_var_chnking_params(struct hashfile_handle *handle,$/;"	f
hashfile_start_time	.\src\libhashfile.cpp	/^uint64_t hashfile_start_time(struct hashfile_handle *handle)$/;"	f
hashfile_sysid	.\src\libhashfile.cpp	/^const char *hashfile_sysid(struct hashfile_handle *handle)$/;"	f
hashfile_var_chunking_params	.\src\libhashfile.cpp	/^int hashfile_var_chunking_params(struct hashfile_handle *handle,$/;"	f
hashfile_version	.\src\libhashfile.cpp	/^uint32_t hashfile_version(struct hashfile_handle *handle)$/;"	f
header	.\src\libhashfile.h	/^	struct header_v4		header;$/;"	m	struct:hashfile_handle	typeref:struct:hashfile_handle::header_v4
header	.\src\libhashfile.h	/^struct header {$/;"	s
header_v3	.\src\libhashfile.h	/^struct header_v3 {$/;"	s
header_v4	.\src\libhashfile.h	/^struct header_v4 {$/;"	s
hex_digit_to_int	.\src\sds.cpp	/^int hex_digit_to_int(char c) {$/;"	f
hit_count	.\src\lru_cache.h	/^	double hit_count;$/;"	m	struct:lruCache
hit_elem	.\src\lru_cache.h	/^	int (*hit_elem)(void* elem, void* user_data);$/;"	m	struct:lruCache
hsh_method	.\src\libhashfile.h	/^	enum hshing_method hsh_method;$/;"	m	struct:header	typeref:enum:header::hshing_method
hsh_method	.\src\libhashfile.h	/^	enum hshing_method hsh_method;$/;"	m	struct:header_v3	typeref:enum:header_v3::hshing_method
hsh_method	.\src\libhashfile.h	/^	enum hshing_method hsh_method;$/;"	m	struct:header_v4	typeref:enum:header_v4::hshing_method
hshing_method	.\src\libhashfile.h	/^enum hshing_method$/;"	g
htable	.\src\kvstore_htable.cpp	/^static GHashTable *htable;$/;"	v	file:
id	.\src\cap_rewrite.cpp	/^	int64_t id;$/;"	m	struct:containerchunkcount	file:
id	.\src\cma.cpp	/^    containerid id;$/;"	m	struct:record	file:
id	.\src\containerstore.h	/^	containerid id;$/;"	m	struct:containerMeta
id	.\src\destor.h	/^	containerid id;$/;"	m	struct:chunk
id	.\src\destor.h	/^	segmentid id;$/;"	m	struct:segment
id	.\src\index_buffer.h	/^    containerid id;$/;"	m	struct:indexElem
id	.\src\jcr.h	/^	int32_t id;$/;"	m	struct:structjcr
id	.\src\ned_rewrite.cpp	/^	int64_t id;$/;"	m	struct:containerchunkcount	file:
id	.\src\recipestore.h	/^	containerid id;$/;"	m	struct:chunkPointer
id	.\src\recipestore.h	/^	segmentid id;$/;"	m	struct:segmentRecipe
id_to_bnum	.\src\recipestore.cpp	/^static inline int64_t id_to_bnum(segmentid id) {$/;"	f	file:
id_to_off	.\src\recipestore.cpp	/^static inline int64_t id_to_off(segmentid id) {$/;"	f	file:
id_to_size	.\src\recipestore.cpp	/^static inline int64_t id_to_size(segmentid id) {$/;"	f	file:
in_dict	.\src\bloom_filter.cpp	/^int in_dict(unsigned char filter[], char *str, int len)$/;"	f
indexElem	.\src\index_buffer.h	/^struct indexElem {$/;"	s
index_bloom_filter_size	.\src\destor.h	/^	int index_bloom_filter_size;$/;"	m	struct:structdestor
index_buffer	.\src\index.cpp	/^struct index_buffer index_buffer;$/;"	v	typeref:struct:index_buffer
index_buffer	.\src\index_buffer.h	/^struct index_buffer {$/;"	s
index_cache_size	.\src\destor.h	/^	int index_cache_size;$/;"	m	struct:structdestor
index_category	.\src\destor.h	/^	int index_category[2];$/;"	m	struct:structdestor
index_check_buffer	.\src\index.cpp	/^void index_check_buffer(struct segment *s) {$/;"	f
index_delete	.\src\index.cpp	/^void index_delete(fingerprint *fp, int64_t id){$/;"	f
index_key_size	.\src\destor.h	/^	int index_key_size;$/;"	m	struct:structdestor
index_key_value_store	.\src\destor.h	/^	int index_key_value_store;$/;"	m	struct:structdestor
index_lock	.\src\dedup_phase.cpp	/^struct structindexlock index_lock;$/;"	v	typeref:struct:structindexlock
index_lookup	.\src\index.cpp	/^int index_lookup(struct segment* s) {$/;"	f
index_lookup_base	.\src\index.cpp	/^static void index_lookup_base(struct segment *s){$/;"	f	file:
index_lookup_similarity_detection	.\src\similarity_detection.cpp	/^void index_lookup_similarity_detection(struct segment *s){$/;"	f
index_memory_footprint	.\src\destor.h	/^	int32_t index_memory_footprint;$/;"	m	struct:structdestor
index_overhead	.\src\index.cpp	/^struct index_overhead index_overhead;$/;"	v	typeref:struct:index_overhead
index_overhead	.\src\index_buffer.h	/^struct index_overhead {$/;"	s
index_sampling_method	.\src\destor.h	/^	int index_sampling_method[2];$/;"	m	struct:structdestor
index_sampling_min	.\src\sampling_method.cpp	/^static GHashTable* index_sampling_min(GSequence *chunks, int32_t chunk_num) {$/;"	f	file:
index_sampling_optimized_min	.\src\sampling_method.cpp	/^static GHashTable* index_sampling_optimized_min(GSequence *chunks,$/;"	f	file:
index_sampling_random	.\src\sampling_method.cpp	/^static GHashTable* index_sampling_random(GSequence *chunks, int32_t chunk_num) {$/;"	f	file:
index_sampling_uniform	.\src\sampling_method.cpp	/^static GHashTable* index_sampling_uniform(GSequence *chunks, int32_t chunk_num) {$/;"	f	file:
index_segment_algorithm	.\src\destor.h	/^	int index_segment_algorithm[2];$/;"	m	struct:structdestor
index_segment_max	.\src\destor.h	/^	int index_segment_max;$/;"	m	struct:structdestor
index_segment_min	.\src\destor.h	/^	int index_segment_min;$/;"	m	struct:structdestor
index_segment_prefech	.\src\destor.h	/^	int index_segment_prefech;$/;"	m	struct:structdestor
index_segment_selection_method	.\src\destor.h	/^	int index_segment_selection_method[2];$/;"	m	struct:structdestor
index_specific	.\src\destor.h	/^	int index_specific;$/;"	m	struct:structdestor
index_update	.\src\index.cpp	/^void index_update(GHashTable *features, int64_t id){$/;"	f
index_update_buffer	.\src\index.cpp	/^int index_update_buffer(struct segment *s){$/;"	f
index_value_length	.\src\destor.h	/^	int index_value_length;$/;"	m	struct:structdestor
inherited_sparse_containers	.\src\har_rewrite.cpp	/^static GHashTable *inherited_sparse_containers;$/;"	v	file:
inherited_sparse_num	.\src\jcr.h	/^	int32_t inherited_sparse_num;$/;"	m	struct:structjcr
init_assembly_area	.\src\assembly_restore.cpp	/^static void init_assembly_area() {$/;"	f	file:
init_backup_jcr	.\src\jcr.cpp	/^void init_backup_jcr(char *path) {$/;"	f
init_container_meta	.\src\containerstore.cpp	/^static void init_container_meta(struct containerMeta *meta) {$/;"	f	file:
init_container_store	.\src\containerstore.cpp	/^void init_container_store() {$/;"	f
init_fingerprint_cache	.\src\fingerprint_cache.cpp	/^void init_fingerprint_cache(){$/;"	f
init_har	.\src\har_rewrite.cpp	/^void init_har() {$/;"	f
init_index	.\src\index.cpp	/^void init_index() {$/;"	f
init_jcr	.\src\jcr.cpp	/^void init_jcr(char *path) {$/;"	f
init_kvstore	.\src\kvstore.cpp	/^void init_kvstore() {$/;"	f
init_kvstore_htable	.\src\kvstore_htable.cpp	/^void init_kvstore_htable(){$/;"	f
init_optimal_cache	.\src\optimal_restore.cpp	/^void init_optimal_cache() {$/;"	f
init_recipe_store	.\src\recipestore.cpp	/^void init_recipe_store() {$/;"	f
init_restore_aware	.\src\restore_aware.cpp	/^void init_restore_aware() {$/;"	f
init_restore_jcr	.\src\jcr.cpp	/^void init_restore_jcr(int revision, char *path) {$/;"	f
init_rewrite_buffer	.\src\rewrite_phase.cpp	/^static void init_rewrite_buffer() {$/;"	f	file:
init_sampling_method	.\src\sampling_method.cpp	/^void init_sampling_method(){$/;"	f
init_segmenting_method	.\src\segmenting_method.cpp	/^void init_segmenting_method(){$/;"	f
init_utility_buckets	.\src\cbr_rewrite.cpp	/^void init_utility_buckets() {$/;"	f
inodenum	.\src\libhashfile.h	/^	uint64_t inodenum;		\/* file inode number *\/$/;"	m	struct:file_header_v3
inodenum	.\src\libhashfile.h	/^	uint64_t inodenum;		\/* file inode number *\/$/;"	m	struct:file_header_v4
inodenum	.\src\libhashfile.h	/^	uint64_t inodenum;$/;"	m	struct:abstract_file_header
insert_word	.\src\bloom_filter.cpp	/^void insert_word(unsigned char filter[], char *str, int len)$/;"	f
is_container_selected	.\src\smr_rewrite.cpp	/^bool is_container_selected[MAX_CONTAINER_COUNT];$/;"	v
is_hex_digit	.\src\sds.cpp	/^int is_hex_digit(char c) {$/;"	f
jcr	.\src\jcr.cpp	/^struct structjcr jcr;$/;"	v	typeref:struct:structjcr
kv_update	.\src\kvstore_htable.cpp	/^static void kv_update(kvpair kv, int64_t id){$/;"	f	file:
kvpair	.\src\kvstore_htable.cpp	/^typedef unsigned char* kvpair;$/;"	t	file:
kvpair_size	.\src\kvstore_htable.cpp	/^static int32_t kvpair_size;$/;"	v	file:
kvpairs	.\src\recipestore.h	/^	GHashTable *kvpairs;$/;"	m	struct:segmentRecipe
kvstore_delete	.\src\kvstore.cpp	/^void (*kvstore_delete)(unsigned char* key, int64_t id);$/;"	v
kvstore_htable_delete	.\src\kvstore_htable.cpp	/^void kvstore_htable_delete(unsigned char* key, int64_t id){$/;"	f
kvstore_htable_lookup	.\src\kvstore_htable.cpp	/^int64_t* kvstore_htable_lookup(unsigned char* key) {$/;"	f
kvstore_htable_update	.\src\kvstore_htable.cpp	/^void kvstore_htable_update(unsigned char* key, int64_t id) {$/;"	f
kvstore_lookup	.\src\kvstore.cpp	/^int64_t* (*kvstore_lookup)(unsigned char *key);$/;"	v
kvstore_update	.\src\kvstore.cpp	/^void (*kvstore_update)(unsigned char *key, int64_t id);$/;"	v
last	.\src\queue.h	/^	queue_ele_t *first, *last; \/* work queue *\/$/;"	m	struct:queue_tag
len	.\src\containerstore.cpp	/^	int32_t len;$/;"	m	struct:metaEntry	file:
len	.\src\sds.h	/^    int len;$/;"	m	struct:sdshdr
live_container_num	.\src\destor.h	/^	int32_t live_container_num;$/;"	m	struct:structdestor
load_config	.\src\config.cpp	/^void load_config() {$/;"	f
load_config_from_string	.\src\config.cpp	/^void load_config_from_string(sds config) {$/;"	f
long_options	.\src\destor.cpp	/^struct option long_options[] = {$/;"	v	typeref:struct:option
lookup_fingerprint_in_container	.\src\containerstore.cpp	/^int lookup_fingerprint_in_container(void *c1, void *fp1) {$/;"	f
lookup_fingerprint_in_container_meta	.\src\containerstore.cpp	/^int lookup_fingerprint_in_container_meta(void *cm1, void *fp1) {$/;"	f
lookup_fingerprint_in_segment_recipe	.\src\recipestore.cpp	/^int lookup_fingerprint_in_segment_recipe(void *sr1, void *fp1) {$/;"	f
lookup_requests	.\src\do_backup.cpp	/^	int lookup_requests;$/;"	m	struct:__anon3	file:
lookup_requests	.\src\fingerprint_cache.cpp	/^	int lookup_requests;$/;"	m	struct:__anon4	file:
lookup_requests	.\src\index_buffer.h	/^    int lookup_requests;$/;"	m	struct:index_overhead
lookup_requests_for_unique	.\src\do_backup.cpp	/^	int lookup_requests_for_unique;$/;"	m	struct:__anon3	file:
lookup_requests_for_unique	.\src\fingerprint_cache.cpp	/^	int lookup_requests_for_unique;$/;"	m	struct:__anon4	file:
lookup_requests_for_unique	.\src\index_buffer.h	/^    int lookup_requests_for_unique;$/;"	m	struct:index_overhead
lruCache	.\src\lru_cache.h	/^struct lruCache {$/;"	s
lru_cache_hits	.\src\lru_cache.cpp	/^void* lru_cache_hits(struct lruCache* c, void* user_data,$/;"	f
lru_cache_insert	.\src\lru_cache.cpp	/^void lru_cache_insert(struct lruCache *c, void* data,$/;"	f
lru_cache_is_full	.\src\lru_cache.cpp	/^int lru_cache_is_full(struct lruCache* c) {$/;"	f
lru_cache_kicks	.\src\lru_cache.cpp	/^void lru_cache_kicks(struct lruCache* c, void* user_data,$/;"	f
lru_cache_lookup	.\src\lru_cache.cpp	/^void* lru_cache_lookup(struct lruCache* c, void* user_data) {$/;"	f
lru_cache_lookup_without_update	.\src\lru_cache.cpp	/^void* lru_cache_lookup_without_update(struct lruCache* c, void* user_data) {$/;"	f
lru_queue	.\src\fingerprint_cache.cpp	/^static struct lruCache* lru_queue;$/;"	v	typeref:struct:lruCache	file:
lru_queue	.\src\optimal_restore.cpp	/^	struct lruCache *lru_queue;$/;"	m	struct:__anon9	typeref:struct:__anon9::lruCache	file:
lru_restore_thread	.\src\do_restore.cpp	/^static void* lru_restore_thread(void *arg) {$/;"	f	file:
magic	.\src\libhashfile.h	/^	uint32_t magic;$/;"	m	struct:header
magic	.\src\libhashfile.h	/^	uint32_t magic;$/;"	m	struct:header_v3
magic	.\src\libhashfile.h	/^	uint32_t magic;$/;"	m	struct:header_v4
main	.\src\destor.cpp	/^int main(int argc, char **argv) {$/;"	f
main	.\src\sds.cpp	/^int main(void) {$/;"	f
make_segment_id	.\src\recipestore.cpp	/^static inline segmentid make_segment_id(int64_t bid, int64_t off, int64_t size){$/;"	f	file:
make_trace	.\src\trace_phase.cpp	/^void make_trace(char* path) {$/;"	f
map	.\src\containerstore.h	/^	GHashTable *map;$/;"	m	struct:containerMeta
max	.\src\libhashfile.cpp	36;"	d	file:
max2	.\src\libhashfile.cpp	35;"	d	file:
max_csize	.\src\libhashfile.h	/^	uint32_t max_csize;		\/* in bytes *\/$/;"	m	struct:var_chnking_params
max_size	.\src\lru_cache.h	/^	int max_size; \/\/ less then zero means infinite cache$/;"	m	struct:lruCache
max_size	.\src\sync_queue.h	/^	int max_size;\/* the max size of queue *\/$/;"	m	struct:__anon12
max_work	.\src\sync_queue.h	/^	pthread_cond_t max_work;$/;"	m	struct:__anon12
meta	.\src\containerstore.h	/^	struct containerMeta meta;$/;"	m	struct:container	typeref:struct:container::containerMeta
metaEntry	.\src\containerstore.cpp	/^struct metaEntry {$/;"	s	file:
metabuf	.\src\recipestore.h	/^	char *metabuf;$/;"	m	struct:backupVersion
metabufoff	.\src\recipestore.h	/^	int metabufoff;$/;"	m	struct:backupVersion
metabufsize	.\src\recipestore.cpp	/^static int metabufsize = 64*1024;$/;"	v	file:
metadata_fp	.\src\recipestore.h	/^	FILE *metadata_fp;$/;"	m	struct:backupVersion
min_csize	.\src\libhashfile.h	/^	uint32_t min_csize;		\/* in bytes *\/$/;"	m	struct:var_chnking_params
min_index	.\src\cbr_rewrite.cpp	/^	int min_index;$/;"	m	struct:__anon2	file:
min_work	.\src\sync_queue.h	/^	pthread_cond_t min_work;$/;"	m	struct:__anon12
miss_count	.\src\lru_cache.h	/^	double miss_count;$/;"	m	struct:lruCache
module	.\src\libhashfile.h	/^	uint64_t module;$/;"	m	struct:var_rabin_chnk_params
monitor	.\src\restore_aware.cpp	/^} monitor;$/;"	v	typeref:struct:__anon11
mtime	.\src\libhashfile.h	/^	uint64_t mtime;			\/* file mtime *\/$/;"	m	struct:file_header_v3
mtime	.\src\libhashfile.h	/^	uint64_t mtime;			\/* file mtime *\/$/;"	m	struct:file_header_v4
mtime	.\src\libhashfile.h	/^	uint64_t mtime;$/;"	m	struct:abstract_file_header
mutex	.\src\cap_rewrite.cpp	/^	pthread_mutex_t mutex;$/;"	m	struct:structindexlock	file:
mutex	.\src\containerstore.cpp	/^static pthread_mutex_t mutex;$/;"	v	file:
mutex	.\src\dedup_phase.cpp	/^	pthread_mutex_t mutex;$/;"	m	struct:structindexlock	file:
mutex	.\src\filter_phase.cpp	/^    pthread_mutex_t mutex;$/;"	m	struct:structindexlock	file:
mutex	.\src\index.cpp	/^    pthread_mutex_t mutex;$/;"	m	struct:structindexlock	file:
mutex	.\src\ned_rewrite.cpp	/^	pthread_mutex_t mutex;$/;"	m	struct:structindexlock	file:
mutex	.\src\smr_rewrite.cpp	/^	pthread_mutex_t mutex;$/;"	m	struct:structindexlock	file:
mutex	.\src\sync_queue.h	/^	pthread_mutex_t mutex;$/;"	m	struct:__anon12
my_memcmp	.\src\ae_chunking.cpp	8;"	d	file:
ned_rewrite	.\src\ned_rewrite.cpp	/^void *ned_rewrite(void* arg) {$/;"	f
new_access_records	.\src\optimal_restore.cpp	/^static struct accessRecords* new_access_records(containerid id) {$/;"	f	file:
new_chunk	.\src\destor.cpp	/^struct chunk* new_chunk(int32_t size) {$/;"	f
new_file_recipe_meta	.\src\recipestore.cpp	/^struct fileRecipeMeta* new_file_recipe_meta(char* name) {$/;"	f
new_kvpair	.\src\kvstore_htable.cpp	/^static kvpair new_kvpair(){$/;"	f	file:
new_kvpair_full	.\src\kvstore_htable.cpp	/^static kvpair new_kvpair_full(unsigned char* key){$/;"	f	file:
new_lru_cache	.\src\lru_cache.cpp	/^struct lruCache* new_lru_cache(int size, void (*free_elem)(void *),$/;"	f
new_segment	.\src\destor.cpp	/^struct segment* new_segment() {$/;"	f
new_segment_full	.\src\destor.cpp	/^struct segment* new_segment_full(){$/;"	f
new_segment_recipe	.\src\recipestore.cpp	/^struct segmentRecipe* new_segment_recipe() {$/;"	f
next	.\src\queue.h	/^	struct queue_ele_tag *next;$/;"	m	struct:queue_ele_tag	typeref:struct:queue_ele_tag::queue_ele_tag
no_rewrite	.\src\rewrite_phase.cpp	/^static void* no_rewrite(void* arg) {$/;"	f	file:
normalized_rabin_chunk_data	.\src\rabin_chunking.cpp	/^int normalized_rabin_chunk_data(unsigned char *p, int n) {$/;"	f
num	.\src\rewrite_phase.h	/^	int num;$/;"	m	struct:structrewritebuffer
num_files_processed	.\src\libhashfile.h	/^	uint64_t			num_files_processed;$/;"	m	struct:hashfile_handle
num_hashes_processed_current_file	.\src\libhashfile.h	/^	uint64_t			num_hashes_processed_current_file;$/;"	m	struct:hashfile_handle
number_of_chunks	.\src\recipestore.h	/^	int64_t number_of_chunks;$/;"	m	struct:backupVersion
number_of_files	.\src\recipestore.h	/^	int64_t number_of_files;$/;"	m	struct:backupVersion
ocf	.\src\restore_aware.cpp	/^	int ocf; \/\/data amount\/CONTAINER_SIZE$/;"	m	struct:__anon11	file:
off	.\src\containerstore.cpp	/^	int32_t off;$/;"	m	struct:metaEntry	file:
omode	.\src\libhashfile.h	/^	enum openmode			omode;$/;"	m	struct:hashfile_handle	typeref:enum:hashfile_handle::openmode
open_backup_version	.\src\recipestore.cpp	/^struct backupVersion* open_backup_version(int number) {$/;"	f
openmode	.\src\libhashfile.h	/^enum openmode {$/;"	g
operator <	.\src\cap_rewrite.cpp	/^	bool operator < (const containerchunkcount &a) const {$/;"	f	struct:containerchunkcount
operator <	.\src\ned_rewrite.cpp	/^	bool operator < (const containerchunkcount &a) const {$/;"	f	struct:containerchunkcount
optimal_cache	.\src\optimal_restore.cpp	/^} optimal_cache;$/;"	v	typeref:struct:__anon9
optimal_cache_hits	.\src\optimal_restore.cpp	/^static int optimal_cache_hits(containerid id) {$/;"	f	file:
optimal_cache_insert	.\src\optimal_restore.cpp	/^static void optimal_cache_insert(containerid id) {$/;"	f	file:
optimal_cache_lookup	.\src\optimal_restore.cpp	/^static struct chunk* optimal_cache_lookup(fingerprint *fp) {$/;"	f	file:
optimal_cache_window_fill	.\src\optimal_restore.cpp	/^static void optimal_cache_window_fill() {$/;"	f	file:
optimal_cache_window_slides	.\src\optimal_restore.cpp	/^static void optimal_cache_window_slides(containerid id) {$/;"	f	file:
optimal_restore_thread	.\src\optimal_restore.cpp	/^void* optimal_restore_thread(void *arg) {$/;"	f
out_of_order	.\src\rewrite_phase.h	/^	int32_t out_of_order;$/;"	m	struct:containerRecord
path	.\src\jcr.h	/^	sds path;$/;"	m	struct:structjcr
path	.\src\libhashfile.h	/^	char path[0];			\/* non-null terminated path$/;"	m	struct:file_header_v2
path	.\src\libhashfile.h	/^	char path[0];			\/* non-null terminated path$/;"	m	struct:file_header_v3
path	.\src\libhashfile.h	/^	char path[0];			\/* non-null terminated path$/;"	m	struct:file_header_v4
path	.\src\libhashfile.h	/^	char path[MAX_PATH_SIZE];$/;"	m	struct:abstract_file_header
path	.\src\libhashfile.h	/^	char path[MAX_PATH_SIZE];$/;"	m	struct:file_header
path	.\src\recipestore.h	/^	sds path;$/;"	m	struct:backupVersion
path_root	.\src\libhashfile.h	/^	char path_root[MAX_PATH_SIZE];	\/* where the scan has started *\/$/;"	m	struct:header
path_root	.\src\libhashfile.h	/^	char path_root[MAX_PATH_SIZE];	\/* where the scan has started *\/$/;"	m	struct:header_v3
path_root	.\src\libhashfile.h	/^	char path_root[MAX_PATH_SIZE];	\/* where the scan has started *\/$/;"	m	struct:header_v4
pathlen	.\src\libhashfile.h	/^	uint32_t pathlen;		\/* length of the following path *\/$/;"	m	struct:file_header_v2
pathlen	.\src\libhashfile.h	/^	uint32_t pathlen;		\/* length of the following path *\/$/;"	m	struct:file_header_v3
pathlen	.\src\libhashfile.h	/^	uint32_t pathlen;		\/* length of the following path *\/$/;"	m	struct:file_header_v4
pathlen	.\src\libhashfile.h	/^	uint32_t pathlen;$/;"	m	struct:abstract_file_header
pattern	.\src\libhashfile.h	/^	uint64_t pattern;$/;"	m	struct:var_rabin_chnk_params
pattern	.\src\libhashfile.h	/^	uint64_t pattern;$/;"	m	struct:var_simple_chnk_params
perm	.\src\libhashfile.h	/^	uint64_t perm;			\/* file mode *\/$/;"	m	struct:file_header_v3
perm	.\src\libhashfile.h	/^	uint64_t perm;			\/* file mode *\/$/;"	m	struct:file_header_v4
perm	.\src\libhashfile.h	/^	uint64_t perm;$/;"	m	struct:abstract_file_header
poly	.\src\rabin_chunking.cpp	/^UINT64 poly;$/;"	v
polymmult	.\src\rabin_chunking.cpp	/^UINT64 polymmult(UINT64 x, UINT64 y, UINT64 d) {$/;"	f
polymod	.\src\rabin_chunking.cpp	/^UINT64 polymod(UINT64 nh, UINT64 nl, UINT64 d) {$/;"	f
polymult	.\src\rabin_chunking.cpp	/^void polymult(UINT64 *php, UINT64 *plp, UINT64 x, UINT64 y) {$/;"	f
prefetch_segments	.\src\recipestore.cpp	/^GQueue* prefetch_segments(segmentid id, int prefetch_num) {$/;"	f
prime	.\src\libhashfile.h	/^	uint64_t prime;$/;"	m	struct:var_rabin_chnk_params
print_chunk_hash	.\src\read_fsl_trace.cpp	/^static void print_chunk_hash(uint64_t chunk_count, const uint8_t *hash,$/;"	f	file:
probability	.\src\libhashfile.h	/^	long double probability;	\/* probability to chunk a stream *\/$/;"	m	struct:var_random_chnk_params
queue	.\src\sync_queue.h	/^	Queue *queue;$/;"	m	struct:__anon12
queue_ele_t	.\src\queue.h	/^} queue_ele_t;$/;"	t	typeref:struct:queue_ele_tag
queue_ele_tag	.\src\queue.h	/^typedef struct queue_ele_tag {$/;"	s
queue_empty	.\src\queue.cpp	/^void queue_empty(Queue *queue, void (*free_data)(void*)) {$/;"	f
queue_find	.\src\queue.cpp	/^void* queue_find(Queue* queue, int (*hit)(void*, void*), void* data) {$/;"	f
queue_foreach	.\src\queue.cpp	/^void queue_foreach(Queue *queue, void (*func)(void *data, void *user_data),$/;"	f
queue_free	.\src\queue.cpp	/^void queue_free(Queue *queue, void (*free_data)(void*)) {$/;"	f
queue_get_n	.\src\queue.cpp	/^void* queue_get_n(Queue *queue, int n) {$/;"	f
queue_init	.\src\queue.cpp	/^void queue_init(Queue *queue) {$/;"	f
queue_new	.\src\queue.cpp	/^Queue* queue_new() {$/;"	f
queue_pop	.\src\queue.cpp	/^void* queue_pop(Queue *queue) {$/;"	f
queue_push	.\src\queue.cpp	/^void queue_push(Queue *queue, void *element) {$/;"	f
queue_size	.\src\queue.cpp	/^int queue_size(Queue *queue) {$/;"	f
queue_tag	.\src\queue.h	/^typedef struct queue_tag {$/;"	s
queue_top	.\src\queue.cpp	/^void * queue_top(Queue *queue) {$/;"	f
rabin_chunk_data	.\src\rabin_chunking.cpp	/^int rabin_chunk_data(unsigned char *p, int n) {$/;"	f
rabin_mask	.\src\rabin_chunking.cpp	/^static int rabin_mask = 0;$/;"	v	file:
rabin_params	.\src\libhashfile.h	/^		struct var_rabin_chnk_params rabin_params;$/;"	m	union:var_chnking_params::__anon5	typeref:struct:var_chnking_params::__anon5::var_rabin_chnk_params
rabinpoly_init	.\src\rabin_chunking.cpp	/^void rabinpoly_init(UINT64 p) {$/;"	f
read_chunk_time	.\src\jcr.h	/^	double read_chunk_time;$/;"	m	struct:structjcr
read_container_num	.\src\jcr.h	/^	int32_t read_container_num;$/;"	m	struct:structjcr
read_file	.\src\read_phase.cpp	/^static void read_file(sds path) {$/;"	f	file:
read_fsl_trace	.\src\read_fsl_trace.cpp	/^void* read_fsl_trace(void *argv)$/;"	f
read_next_file_recipe_meta	.\src\recipestore.cpp	/^struct fileRecipeMeta* read_next_file_recipe_meta(struct backupVersion* b) {$/;"	f
read_next_n_chunk_pointers	.\src\recipestore.cpp	/^struct chunkPointer* read_next_n_chunk_pointers(struct backupVersion* b, int n,$/;"	f
read_next_n_records	.\src\recipestore.cpp	/^containerid* read_next_n_records(struct backupVersion* b, int n, int *k) {$/;"	f
read_next_segment	.\src\recipestore.cpp	/^struct segmentRecipe* read_next_segment(struct backupVersion *bv){$/;"	f
read_prefetching_units	.\src\do_backup.cpp	/^	int read_prefetching_units;$/;"	m	struct:__anon3	file:
read_prefetching_units	.\src\fingerprint_cache.cpp	/^	int read_prefetching_units;$/;"	m	struct:__anon4	file:
read_prefetching_units	.\src\index_buffer.h	/^    int read_prefetching_units;$/;"	m	struct:index_overhead
read_queue	.\src\read_phase.cpp	/^SyncQueue* read_queue;$/;"	v
read_recipe_thread	.\src\do_restore.cpp	/^static void* read_recipe_thread(void *arg) {$/;"	f	file:
read_recipe_time	.\src\jcr.h	/^	double read_recipe_time;$/;"	m	struct:structjcr
read_t	.\src\read_phase.cpp	/^static pthread_t read_t;$/;"	v	file:
read_thread	.\src\read_phase.cpp	/^static void* read_thread(void *argv) {$/;"	f	file:
read_time	.\src\jcr.h	/^	double read_time;$/;"	m	struct:structjcr
read_trace_thread	.\src\trace_phase.cpp	/^static void* read_trace_thread(void *argv) {$/;"	f	file:
real_containerid_to_tmp	.\src\cap_rewrite.cpp	/^GHashTable *real_containerid_to_tmp;$/;"	v
real_containerid_to_tmp	.\src\ned_rewrite.cpp	/^GHashTable *real_containerid_to_tmp;$/;"	v
real_containerid_to_tmp	.\src\smr_rewrite.cpp	/^GHashTable *real_containerid_to_tmp;$/;"	v
recipe_fp	.\src\recipestore.h	/^	FILE *recipe_fp;$/;"	m	struct:backupVersion
recipepath	.\src\recipestore.cpp	/^static sds recipepath;$/;"	v	file:
record	.\src\cma.cpp	/^struct record{$/;"	s	file:
record_fp	.\src\recipestore.h	/^	FILE *record_fp;$/;"	m	struct:backupVersion
recordbuf	.\src\recipestore.h	/^	char *recordbuf;$/;"	m	struct:backupVersion
recordbufoff	.\src\recipestore.h	/^	int recordbufoff;$/;"	m	struct:backupVersion
recordbufsize	.\src\recipestore.cpp	/^static int recordbufsize = 64*1024;$/;"	v	file:
restore_aware_contains	.\src\restore_aware.cpp	/^int restore_aware_contains(containerid id) {$/;"	f
restore_aware_get_cfl	.\src\restore_aware.cpp	/^double restore_aware_get_cfl() {$/;"	f
restore_aware_update	.\src\restore_aware.cpp	/^void restore_aware_update(containerid id, int32_t chunklen) {$/;"	f
restore_cache	.\src\destor.h	/^	int restore_cache[2];$/;"	m	struct:structdestor
restore_chunk_queue	.\src\do_restore.cpp	/^SyncQueue *restore_chunk_queue;$/;"	v
restore_opt_window_size	.\src\destor.h	/^	int restore_opt_window_size;$/;"	m	struct:structdestor
restore_recipe_queue	.\src\do_restore.cpp	/^SyncQueue *restore_recipe_queue;$/;"	v
retrieve_container_by_id	.\src\containerstore.cpp	/^struct container* retrieve_container_by_id(containerid id) {$/;"	f
retrieve_container_meta_by_id	.\src\containerstore.cpp	/^struct containerMeta* retrieve_container_meta_by_id(containerid id) {$/;"	f
rewrite_algorithm	.\src\destor.h	/^	int rewrite_algorithm[2];$/;"	m	struct:structdestor
rewrite_buffer	.\src\rewrite_phase.cpp	/^struct structrewritebuffer rewrite_buffer;$/;"	v	typeref:struct:structrewritebuffer
rewrite_buffer_chunk_pt	.\src\cap_rewrite.cpp	/^vector <chunk *> rewrite_buffer_chunk_pt;$/;"	v
rewrite_buffer_chunk_pt	.\src\ned_rewrite.cpp	/^vector <chunk *> rewrite_buffer_chunk_pt;$/;"	v
rewrite_buffer_chunk_pt	.\src\smr_rewrite.cpp	/^vector <chunk *> rewrite_buffer_chunk_pt;$/;"	v
rewrite_buffer_pop	.\src\rewrite_phase.cpp	/^struct chunk* rewrite_buffer_pop() {$/;"	f
rewrite_buffer_push	.\src\rewrite_phase.cpp	/^int rewrite_buffer_push(struct chunk* c) {$/;"	f
rewrite_buffer_top	.\src\rewrite_phase.cpp	/^struct chunk* rewrite_buffer_top() {$/;"	f
rewrite_capping_level	.\src\destor.h	/^	int rewrite_capping_level;$/;"	m	struct:structdestor
rewrite_cbr_limit	.\src\destor.h	/^	double rewrite_cbr_limit;$/;"	m	struct:structdestor
rewrite_cbr_minimal_utility	.\src\destor.h	/^	double rewrite_cbr_minimal_utility;$/;"	m	struct:structdestor
rewrite_cfl_require	.\src\destor.h	/^	double rewrite_cfl_require;$/;"	m	struct:structdestor
rewrite_cfl_usage_threshold	.\src\destor.h	/^	double rewrite_cfl_usage_threshold;$/;"	m	struct:structdestor
rewrite_enable_cache_aware	.\src\destor.h	/^	int rewrite_enable_cache_aware;$/;"	m	struct:structdestor
rewrite_enable_cfl_switch	.\src\destor.h	/^	int rewrite_enable_cfl_switch;$/;"	m	struct:structdestor
rewrite_enable_har	.\src\destor.h	/^	int rewrite_enable_har;$/;"	m	struct:structdestor
rewrite_har_rewrite_limit	.\src\destor.h	/^	double rewrite_har_rewrite_limit;$/;"	m	struct:structdestor
rewrite_har_utilization_threshold	.\src\destor.h	/^	double rewrite_har_utilization_threshold;$/;"	m	struct:structdestor
rewrite_ned_level	.\src\destor.h	/^	int rewrite_ned_level;$/;"	m	struct:structdestor
rewrite_queue	.\src\rewrite_phase.cpp	/^SyncQueue* rewrite_queue;$/;"	v
rewrite_smr_level	.\src\destor.h	/^	int rewrite_smr_level;$/;"	m	struct:structdestor
rewrite_t	.\src\rewrite_phase.cpp	/^static pthread_t rewrite_t;$/;"	v	file:
rewrite_time	.\src\jcr.h	/^	double rewrite_time;$/;"	m	struct:structjcr
rewritten_chunk_num	.\src\destor.h	/^	int64_t rewritten_chunk_num;$/;"	m	struct:structdestor
rewritten_chunk_num	.\src\jcr.h	/^	int32_t rewritten_chunk_num;$/;"	m	struct:structjcr
rewritten_chunk_size	.\src\destor.h	/^	int64_t rewritten_chunk_size;$/;"	m	struct:structdestor
rewritten_chunk_size	.\src\jcr.h	/^	int64_t rewritten_chunk_size;$/;"	m	struct:structjcr
rnd_params	.\src\libhashfile.h	/^		struct var_random_chnk_params rnd_params;$/;"	m	union:var_chnking_params::__anon5	typeref:struct:var_chnking_params::__anon5::var_random_chnk_params
sampling	.\src\sampling_method.cpp	/^GHashTable* (*sampling)(GSequence *chunks, int32_t chunk_num);$/;"	v
sds	.\src\sds.h	/^typedef char *sds;$/;"	t
sdsAllocSize	.\src\sds.cpp	/^size_t sdsAllocSize(sds s) {$/;"	f
sdsIncrLen	.\src\sds.cpp	/^void sdsIncrLen(sds s, int incr) {$/;"	f
sdsMakeRoomFor	.\src\sds.cpp	/^sds sdsMakeRoomFor(sds s, size_t addlen) {$/;"	f
sdsRemoveFreeSpace	.\src\sds.cpp	/^sds sdsRemoveFreeSpace(sds s) {$/;"	f
sdsavail	.\src\sds.h	/^static inline size_t sdsavail(const sds s) {$/;"	f
sdscat	.\src\sds.cpp	/^sds sdscat(sds s, const char *t) {$/;"	f
sdscatlen	.\src\sds.cpp	/^sds sdscatlen(sds s, const void *t, size_t len) {$/;"	f
sdscatprintf	.\src\sds.cpp	/^sds sdscatprintf(sds s, const char *fmt, ...) {$/;"	f
sdscatrepr	.\src\sds.cpp	/^sds sdscatrepr(sds s, const char *p, size_t len) {$/;"	f
sdscatsds	.\src\sds.cpp	/^sds sdscatsds(sds s, const sds t) {$/;"	f
sdscatvprintf	.\src\sds.cpp	/^sds sdscatvprintf(sds s, const char *fmt, va_list ap) {$/;"	f
sdsclear	.\src\sds.cpp	/^void sdsclear(sds s) {$/;"	f
sdscmp	.\src\sds.cpp	/^int sdscmp(const sds s1, const sds s2) {$/;"	f
sdscpy	.\src\sds.cpp	/^sds sdscpy(sds s, const char *t) {$/;"	f
sdscpylen	.\src\sds.cpp	/^sds sdscpylen(sds s, const char *t, size_t len) {$/;"	f
sdsdup	.\src\sds.cpp	/^sds sdsdup(const sds s) {$/;"	f
sdsempty	.\src\sds.cpp	/^sds sdsempty(void) {$/;"	f
sdsfree	.\src\sds.cpp	/^void sdsfree(sds s) {$/;"	f
sdsfreesplitres	.\src\sds.cpp	/^void sdsfreesplitres(sds *tokens, int count) {$/;"	f
sdsfromlonglong	.\src\sds.cpp	/^sds sdsfromlonglong(long long value) {$/;"	f
sdsgrowzero	.\src\sds.cpp	/^sds sdsgrowzero(sds s, size_t len) {$/;"	f
sdshdr	.\src\sds.h	/^struct sdshdr {$/;"	s
sdsjoin	.\src\sds.cpp	/^sds sdsjoin(char **argv, int argc, char *sep) {$/;"	f
sdslen	.\src\sds.h	/^static inline size_t sdslen(const sds s) {$/;"	f
sdsmapchars	.\src\sds.cpp	/^sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {$/;"	f
sdsnew	.\src\sds.cpp	/^sds sdsnew(const char *init) {$/;"	f
sdsnewlen	.\src\sds.cpp	/^sds sdsnewlen(const void *init, size_t initlen) {$/;"	f
sdsrange	.\src\sds.cpp	/^void sdsrange(sds s, int start, int end) {$/;"	f
sdssplitargs	.\src\sds.cpp	/^sds *sdssplitargs(const char *line, int *argc) {$/;"	f
sdssplitlen	.\src\sds.cpp	/^sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count) {$/;"	f
sdstolower	.\src\sds.cpp	/^void sdstolower(sds s) {$/;"	f
sdstoupper	.\src\sds.cpp	/^void sdstoupper(sds s) {$/;"	f
sdstrim	.\src\sds.cpp	/^sds sdstrim(sds s, const char *cset) {$/;"	f
sdsupdatelen	.\src\sds.cpp	/^void sdsupdatelen(sds s) {$/;"	f
segment	.\src\destor.h	/^struct segment {$/;"	s
segmentRecipe	.\src\recipestore.h	/^struct segmentRecipe {$/;"	s
segment_content_defined	.\src\segmenting_method.cpp	/^static struct segment* segment_content_defined(struct chunk *c) {$/;"	f	file:
segment_file_defined	.\src\segmenting_method.cpp	/^static struct segment* segment_file_defined(struct chunk *c) {$/;"	f	file:
segment_fixed	.\src\segmenting_method.cpp	/^static struct segment* segment_fixed(struct chunk * c) {$/;"	f	file:
segment_num	.\src\dedup_phase.cpp	/^static int64_t segment_num;$/;"	v	file:
segment_recipe_check_id	.\src\recipestore.cpp	/^int segment_recipe_check_id(void *sr1, void *id1) {$/;"	f
segment_recipe_foreach	.\src\recipestore.cpp	/^void segment_recipe_foreach(struct segmentRecipe* sr, void (*func)(fingerprint*, void*), void* data){$/;"	f
segmentbuf	.\src\recipestore.h	/^	char* segmentbuf;$/;"	m	struct:backupVersion
segmentbufoff	.\src\recipestore.h	/^	int segmentbufoff;$/;"	m	struct:backupVersion
segmentid	.\src\destor.h	/^typedef int64_t segmentid;$/;"	t
segmenting	.\src\segmenting_method.cpp	/^struct segment* (*segmenting)(struct chunk *c);$/;"	v	typeref:struct:segmenting
segmentlen	.\src\recipestore.h	/^	int segmentlen;$/;"	m	struct:backupVersion
send_segment	.\src\dedup_phase.cpp	/^void send_segment(struct segment* s) {$/;"	f
seqno_queue	.\src\optimal_restore.cpp	/^	GQueue *seqno_queue;$/;"	m	struct:accessRecords	file:
ser_begin	.\src\serial.h	42;"	d
ser_btime	.\src\serial.h	81;"	d
ser_bytes	.\src\serial.h	87;"	d
ser_check	.\src\serial.h	56;"	d
ser_declare	.\src\serial.h	38;"	d
ser_end	.\src\serial.h	51;"	d
ser_float64	.\src\serial.h	84;"	d
ser_int16	.\src\serial.h	66;"	d
ser_int32	.\src\serial.h	71;"	d
ser_int64	.\src\serial.h	76;"	d
ser_int8	.\src\serial.h	61;"	d
ser_length	.\src\serial.h	47;"	d
ser_string	.\src\serial.h	93;"	d
ser_struct	.\src\serial.h	90;"	d
ser_uint16	.\src\serial.h	68;"	d
ser_uint32	.\src\serial.h	73;"	d
ser_uint64	.\src\serial.h	78;"	d
ser_uint8	.\src\serial.h	63;"	d
serial_int16	.\src\serial.cpp	/^void serial_int16(uint8_t * * const ptr, const int16_t v)$/;"	f
serial_int32	.\src\serial.cpp	/^void serial_int32(uint8_t * * const ptr, const int32_t v)$/;"	f
serial_int64	.\src\serial.cpp	/^void serial_int64(uint8_t * * const ptr, const int64_t v)$/;"	f
serial_string	.\src\serial.cpp	/^void serial_string(uint8_t * * const ptr, const char * const str)$/;"	f
serial_uint16	.\src\serial.cpp	/^void serial_uint16(uint8_t * * const ptr, const uint16_t v)$/;"	f
serial_uint32	.\src\serial.cpp	/^void serial_uint32(uint8_t * * const ptr, const uint32_t v)$/;"	f
serial_uint64	.\src\serial.cpp	/^void serial_uint64(uint8_t * * const ptr, const uint64_t v)$/;"	f
sha1_thread	.\src\hash_phase.cpp	/^static void* sha1_thread(void* arg) {$/;"	f	file:
shift	.\src\rabin_chunking.cpp	/^int shift;$/;"	v
short_options	.\src\destor.cpp	/^const char * const short_options = "sr::t::p::h";$/;"	v
simple_params	.\src\libhashfile.h	/^		struct var_simple_chnk_params simple_params;$/;"	m	union:var_chnking_params::__anon5	typeref:struct:var_chnking_params::__anon5::var_simple_chnk_params
simulation_level	.\src\destor.h	/^	int simulation_level;$/;"	m	struct:structdestor
size	.\src\assembly_restore.cpp	/^	int64_t size;$/;"	m	struct:__anon1	file:
size	.\src\destor.h	/^	int32_t size;$/;"	m	struct:chunk
size	.\src\libhashfile.h	/^	uint64_t size;$/;"	m	struct:chunk_info
size	.\src\lru_cache.h	/^	int size;$/;"	m	struct:lruCache
size	.\src\rabin_chunking.cpp	/^	size = 48$/;"	e	enum:__anon10	file:
size	.\src\recipestore.h	/^	int32_t size;$/;"	m	struct:chunkPointer
size	.\src\rewrite_phase.h	/^	int size;$/;"	m	struct:structrewritebuffer
size	.\src\rewrite_phase.h	/^	int32_t size;$/;"	m	struct:containerRecord
skip_over_current_file_hashes	.\src\libhashfile.cpp	/^static uint64_t skip_over_current_file_hashes(struct hashfile_handle *handle)$/;"	f	file:
slide8	.\src\rabin_chunking.cpp	/^UINT64 slide8(unsigned char m) {$/;"	f
smr_rewrite	.\src\smr_rewrite.cpp	/^void *smr_rewrite(void* arg) {$/;"	f
sorted_records_of_cached_containers	.\src\optimal_restore.cpp	/^	GSequence *sorted_records_of_cached_containers;$/;"	m	struct:__anon9	file:
sparse_container_num	.\src\jcr.h	/^	int32_t sparse_container_num;$/;"	m	struct:structjcr
split_file	.\scripts\benchmark.sh	/^split_file(){$/;"	f
split_file	.\scripts\cache.sh	/^split_file(){$/;"	f
split_file	.\scripts\caf.sh	/^split_file(){$/;"	f
split_file	.\scripts\hybrid.sh	/^split_file(){$/;"	f
split_file	.\scripts\rewrite.sh	/^split_file(){$/;"	f
start_chunk_phase	.\src\chunk_phase.cpp	/^void start_chunk_phase() {$/;"	f
start_dedup_phase	.\src\dedup_phase.cpp	/^void start_dedup_phase() {$/;"	f
start_filter_phase	.\src\filter_phase.cpp	/^void start_filter_phase() {$/;"	f
start_hash_phase	.\src\hash_phase.cpp	/^void start_hash_phase() {$/;"	f
start_read_phase	.\src\read_phase.cpp	/^void start_read_phase() {$/;"	f
start_read_trace_phase	.\src\trace_phase.cpp	/^void start_read_trace_phase() {$/;"	f
start_rewrite_phase	.\src\rewrite_phase.cpp	/^void start_rewrite_phase() {$/;"	f
start_time	.\src\libhashfile.h	/^	uint64_t start_time;$/;"	m	struct:header_v3
start_time	.\src\libhashfile.h	/^	uint64_t start_time;$/;"	m	struct:header_v4
status	.\src\jcr.h	/^    int status;$/;"	m	struct:structjcr
stop_chunk_phase	.\src\chunk_phase.cpp	/^void stop_chunk_phase() {$/;"	f
stop_dedup_phase	.\src\dedup_phase.cpp	/^void stop_dedup_phase() {$/;"	f
stop_filter_phase	.\src\filter_phase.cpp	/^void stop_filter_phase() {$/;"	f
stop_hash_phase	.\src\hash_phase.cpp	/^void stop_hash_phase() {$/;"	f
stop_read_phase	.\src\read_phase.cpp	/^void stop_read_phase() {$/;"	f
stop_read_trace_phase	.\src\trace_phase.cpp	/^void stop_read_trace_phase() {$/;"	f
stop_rewrite_phase	.\src\rewrite_phase.cpp	/^void stop_rewrite_phase() {$/;"	f
storage_buffer	.\src\filter_phase.cpp	/^struct structstoragebuffer storage_buffer;$/;"	v	typeref:struct:structstoragebuffer
stored_chunk_num	.\src\destor.h	/^	int64_t stored_chunk_num;$/;"	m	struct:structdestor
stored_data_size	.\src\destor.h	/^	int64_t stored_data_size;$/;"	m	struct:structdestor
structdestor	.\src\destor.h	/^struct structdestor {$/;"	s
structindexlock	.\src\cap_rewrite.cpp	/^struct structindexlock{$/;"	s	file:
structindexlock	.\src\dedup_phase.cpp	/^struct structindexlock{$/;"	s	file:
structindexlock	.\src\filter_phase.cpp	/^struct structindexlock{$/;"	s	file:
structindexlock	.\src\index.cpp	/^struct structindexlock{$/;"	s	file:
structindexlock	.\src\ned_rewrite.cpp	/^struct structindexlock{$/;"	s	file:
structindexlock	.\src\smr_rewrite.cpp	/^struct structindexlock{$/;"	s	file:
structjcr	.\src\jcr.h	/^struct structjcr{$/;"	s
structrewritebuffer	.\src\rewrite_phase.h	/^struct structrewritebuffer {$/;"	s
structstoragebuffer	.\src\filter_phase.cpp	/^struct structstoragebuffer{$/;"	s	file:
structstoragebuffer	.\src\index.cpp	/^struct structstoragebuffer{$/;"	s	file:
structstoragebuffer	.\src\similarity_detection.cpp	/^struct structstoragebuffer{$/;"	s	file:
sync_queue_find	.\src\sync_queue.cpp	/^void* sync_queue_find(SyncQueue* s_queue, int (*hit)(void*, void*), void* data,$/;"	f
sync_queue_free	.\src\sync_queue.cpp	/^void sync_queue_free(SyncQueue* s_queue, void (*free_data)(void*)) {$/;"	f
sync_queue_get_top	.\src\sync_queue.cpp	/^void* sync_queue_get_top(SyncQueue* s_queue) {$/;"	f
sync_queue_new	.\src\sync_queue.cpp	/^SyncQueue* sync_queue_new(int size) {$/;"	f
sync_queue_pop	.\src\sync_queue.cpp	/^void* sync_queue_pop(SyncQueue* s_queue) {$/;"	f
sync_queue_push	.\src\sync_queue.cpp	/^void sync_queue_push(SyncQueue* s_queue, void* item) {$/;"	f
sync_queue_size	.\src\sync_queue.cpp	/^int sync_queue_size(SyncQueue* s_queue) {$/;"	f
sync_queue_term	.\src\sync_queue.cpp	/^void sync_queue_term(SyncQueue* s_queue) {$/;"	f
sysid	.\src\libhashfile.h	/^	char sysid[MAX_SYSID_LEN];$/;"	m	struct:header_v3
sysid	.\src\libhashfile.h	/^	char sysid[MAX_SYSID_LEN];$/;"	m	struct:header_v4
target_path	.\src\libhashfile.h	/^	char target_path[0];		\/* non-null terminated$/;"	m	struct:file_header_v3
target_path	.\src\libhashfile.h	/^	char target_path[0];		\/* non-null terminated$/;"	m	struct:file_header_v4
target_path	.\src\libhashfile.h	/^	char target_path[MAX_PATH_SIZE];$/;"	m	struct:abstract_file_header
target_pathlen	.\src\libhashfile.h	/^	uint32_t target_pathlen;	\/* length of the following target_path *\/$/;"	m	struct:file_header_v3
target_pathlen	.\src\libhashfile.h	/^	uint32_t target_pathlen;	\/* length of the following target_path *\/$/;"	m	struct:file_header_v4
target_pathlen	.\src\libhashfile.h	/^	uint32_t target_pathlen;$/;"	m	struct:abstract_file_header
term	.\src\sync_queue.h	/^	int term; \/\/ terminated$/;"	m	struct:__anon12
time	.\src\cma.cpp	/^    int time;$/;"	m	struct:record	file:
tmp_to_real_containerid	.\src\cap_rewrite.cpp	/^int64_t tmp_to_real_containerid[MAX_CONTAINER_COUNT];$/;"	v
tmp_to_real_containerid	.\src\ned_rewrite.cpp	/^int64_t tmp_to_real_containerid[MAX_CONTAINER_COUNT];$/;"	v
tmp_to_real_containerid	.\src\smr_rewrite.cpp	/^int64_t tmp_to_real_containerid[MAX_CONTAINER_COUNT];$/;"	v
top	.\src\cap_rewrite.cpp	/^static GHashTable *top;$/;"	v	file:
top	.\src\ned_rewrite.cpp	/^static GHashTable *top;$/;"	v	file:
top	.\src\smr_rewrite.cpp	/^static GHashTable *top;$/;"	v	file:
top_segment_select	.\src\similarity_detection.cpp	/^static void top_segment_select(GHashTable* features) {$/;"	f	file:
total_container_num	.\src\jcr.h	/^	int32_t total_container_num;$/;"	m	struct:structjcr
total_size	.\src\restore_aware.cpp	/^	int64_t total_size;$/;"	m	struct:__anon11	file:
total_time	.\src\jcr.h	/^	double total_time;$/;"	m	struct:structjcr
trace_format	.\src\destor.h	/^    int trace_format;$/;"	m	struct:structdestor
trace_queue	.\src\trace_phase.cpp	/^SyncQueue* trace_queue;$/;"	v
trace_t	.\src\trace_phase.cpp	/^static pthread_t trace_t;$/;"	v	file:
trunc_manifest	.\src\cma.cpp	/^GHashTable* trunc_manifest(int jobid){$/;"	f
tttd_chunk_data	.\src\rabin_chunking.cpp	/^int tttd_chunk_data(unsigned char *p, int n) {$/;"	f
uid	.\src\libhashfile.h	/^	uint32_t uid;			\/* uid of file owner *\/$/;"	m	struct:file_header_v3
uid	.\src\libhashfile.h	/^	uint32_t uid;			\/* uid of file owner *\/$/;"	m	struct:file_header_v4
uid	.\src\libhashfile.h	/^	uint32_t uid;$/;"	m	struct:abstract_file_header
unique_chunk_num	.\src\jcr.h	/^	int32_t unique_chunk_num;$/;"	m	struct:structjcr
unique_data_size	.\src\jcr.h	/^	int64_t unique_data_size;$/;"	m	struct:structjcr
unser_begin	.\src\serial.h	43;"	d
unser_btime	.\src\serial.h	118;"	d
unser_bytes	.\src\serial.h	124;"	d
unser_declare	.\src\serial.h	39;"	d
unser_end	.\src\serial.h	52;"	d
unser_float64	.\src\serial.h	121;"	d
unser_int16	.\src\serial.h	103;"	d
unser_int32	.\src\serial.h	108;"	d
unser_int64	.\src\serial.h	113;"	d
unser_int8	.\src\serial.h	98;"	d
unser_length	.\src\serial.h	48;"	d
unser_string	.\src\serial.h	130;"	d
unser_struct	.\src\serial.h	127;"	d
unser_uint16	.\src\serial.h	105;"	d
unser_uint32	.\src\serial.h	110;"	d
unser_uint64	.\src\serial.h	115;"	d
unser_uint8	.\src\serial.h	100;"	d
unserial_int16	.\src\serial.cpp	/^int16_t unserial_int16(uint8_t * * const ptr)$/;"	f
unserial_int32	.\src\serial.cpp	/^int32_t unserial_int32(uint8_t * * const ptr)$/;"	f
unserial_int64	.\src\serial.cpp	/^int64_t unserial_int64(uint8_t * * const ptr)$/;"	f
unserial_string	.\src\serial.cpp	/^void unserial_string(uint8_t * * const ptr, char * const str)$/;"	f
unserial_uint16	.\src\serial.cpp	/^uint16_t unserial_uint16(uint8_t * * const ptr)$/;"	f
unserial_uint32	.\src\serial.cpp	/^uint32_t unserial_uint32(uint8_t * * const ptr)$/;"	f
unserial_uint64	.\src\serial.cpp	/^uint64_t unserial_uint64(uint8_t * * const ptr)$/;"	f
update_backup_version	.\src\recipestore.cpp	/^void update_backup_version(struct backupVersion *b) {$/;"	f
update_manifest	.\src\cma.cpp	/^void update_manifest(GHashTable *monitor){$/;"	f
update_requests	.\src\do_backup.cpp	/^	int update_requests;$/;"	m	struct:__anon3	file:
update_requests	.\src\fingerprint_cache.cpp	/^	int update_requests;$/;"	m	struct:__anon4	file:
update_requests	.\src\index_buffer.h	/^    int update_requests;$/;"	m	struct:index_overhead
usage	.\src\destor.cpp	/^void usage() {$/;"	f
utility_buckets	.\src\cbr_rewrite.cpp	/^} utility_buckets;$/;"	v	typeref:struct:__anon2
utility_buckets_update	.\src\cbr_rewrite.cpp	/^static void utility_buckets_update(double rewrite_utility) {$/;"	f	file:
var_chnking_algo	.\src\libhashfile.h	/^enum var_chnking_algo$/;"	g
var_chnking_params	.\src\libhashfile.h	/^struct var_chnking_params$/;"	s
var_params	.\src\libhashfile.h	/^		struct var_chnking_params var_params;$/;"	m	union:header::__anon6	typeref:struct:header::__anon6::var_chnking_params
var_params	.\src\libhashfile.h	/^		struct var_chnking_params var_params;$/;"	m	union:header_v3::__anon7	typeref:struct:header_v3::__anon7::var_chnking_params
var_params	.\src\libhashfile.h	/^		struct var_chnking_params var_params;$/;"	m	union:header_v4::__anon8	typeref:struct:header_v4::__anon8::var_chnking_params
var_rabin_chnk_params	.\src\libhashfile.h	/^struct var_rabin_chnk_params {$/;"	s
var_random_chnk_params	.\src\libhashfile.h	/^struct var_random_chnk_params {$/;"	s
var_simple_chnk_params	.\src\libhashfile.h	/^struct var_simple_chnk_params {$/;"	s
verbosity	.\src\destor.h	/^	int verbosity;$/;"	m	struct:structdestor
version	.\src\libhashfile.h	/^	uint32_t version;$/;"	m	struct:header
version	.\src\libhashfile.h	/^	uint32_t version;$/;"	m	struct:header_v3
version	.\src\libhashfile.h	/^	uint32_t version;$/;"	m	struct:header_v4
version_supported	.\src\libhashfile.cpp	/^static inline int version_supported(uint32_t version)$/;"	f	file:
victim	.\src\optimal_restore.cpp	/^struct accessRecords* victim;$/;"	v	typeref:struct:accessRecords
wait_threshold	.\src\cap_rewrite.cpp	/^	int wait_threshold;$/;"	m	struct:structindexlock	file:
wait_threshold	.\src\dedup_phase.cpp	/^	int wait_threshold;$/;"	m	struct:structindexlock	file:
wait_threshold	.\src\filter_phase.cpp	/^    int wait_threshold;$/;"	m	struct:structindexlock	file:
wait_threshold	.\src\index.cpp	/^    int wait_threshold;$/;"	m	struct:structindexlock	file:
wait_threshold	.\src\ned_rewrite.cpp	/^	int wait_threshold;$/;"	m	struct:structindexlock	file:
wait_threshold	.\src\smr_rewrite.cpp	/^	int wait_threshold;$/;"	m	struct:structindexlock	file:
window_init	.\src\rabin_chunking.cpp	/^void window_init(UINT64 poly) {$/;"	f
window_size	.\src\ae_chunking.cpp	/^static int window_size = 0;$/;"	v	file:
window_size	.\src\libhashfile.h	/^	uint32_t window_size; 		\/* in bytes *\/$/;"	m	struct:var_rabin_chnk_params
windows_reset	.\src\rabin_chunking.cpp	/^void windows_reset() {$/;"	f
working_directory	.\src\destor.h	/^	sds working_directory;$/;"	m	struct:structdestor
write_chunk_time	.\src\jcr.h	/^	double write_chunk_time;$/;"	m	struct:structjcr
write_container	.\src\containerstore.cpp	/^void write_container(struct container* c) {$/;"	f
write_container_async	.\src\containerstore.cpp	/^void write_container_async(struct container* c) {$/;"	f
write_restore_data	.\src\do_restore.cpp	/^void* write_restore_data(void* arg) {$/;"	f
write_time	.\src\jcr.h	/^	double write_time;$/;"	m	struct:structjcr
yesnotoi	.\src\config.cpp	/^int yesnotoi(char *s) {$/;"	f
zero_chunk_num	.\src\destor.h	/^	int64_t zero_chunk_num;$/;"	m	struct:structdestor
zero_chunk_num	.\src\jcr.h	/^	int32_t zero_chunk_num;$/;"	m	struct:structjcr
zero_chunk_size	.\src\destor.h	/^	int64_t zero_chunk_size;$/;"	m	struct:structdestor
zero_chunk_size	.\src\jcr.h	/^	int64_t zero_chunk_size;$/;"	m	struct:structjcr
